#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 0.2cm
\rightmargin 0.2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Author
Tormod Gjeitnes Hellen
\end_layout

\begin_layout Title
TMR4160
\end_layout

\begin_layout Standard
http://www.cs.ucl.ac.uk/teaching_learning/msc_cgvi/projects/project_report_structure
/
\end_layout

\begin_layout Chapter*
Introduction
\end_layout

\begin_layout Standard
The task given was to numerically solve the Poisson equation under Dirichlet
 and Neumann boundary conditions.
 The Dirichlet case was pretty straightforward to implement and performed
 pretty well on first try.
 In the Neumann case interperting the boundary condition (that the derivative
 normally over the boundary is 0) proved very challenging and frustrating.
\end_layout

\begin_layout Standard
Another source of error was that arrays are 1-indexed, which matters when
 you're trying to determine the coordinates from the matrix index.
\end_layout

\begin_layout Chapter*
Background
\end_layout

\begin_layout Standard
The problem presented is to numerically solve the two-dimensional Poisson
 equation 
\begin_inset Formula $\nabla\text{²}\varphi:=\frac{\delta\text{²}\varphi}{\delta x\text{²}}+\frac{\delta\text{²}\varphi}{\delta y\text{²}}=f(x,y)$
\end_inset

( find 
\begin_inset Formula $\varphi$
\end_inset

) under three different conditions
\end_layout

\begin_layout Enumerate
With 
\begin_inset Formula $f(x,y)=1$
\end_inset

 generally and 
\begin_inset Formula $\varphi(x,y)=\frac{1}{4}(x\text{²}+y\text{²})$
\end_inset

 on the boundary(Dirichlet condition)
\end_layout

\begin_layout Enumerate
With 
\begin_inset Formula $f(x,y)=12-12x-12y$
\end_inset

 generally, 
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

 and 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 on the boundary(Neumann condition), where 
\begin_inset Formula $n$
\end_inset

 is a vector normal to the boundary.
\end_layout

\begin_layout Enumerate
With 
\begin_inset Formula $f(x,y)=(6-12x)(3y\text{²}-2y\text{³})+(3x\text{²}-2x\text{³})(6-12y)$
\end_inset

 generally, 
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

 and 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 on the boundary(Neumann condition), where 
\begin_inset Formula $n$
\end_inset

 is a vector normal to the boundary.
\end_layout

\begin_layout Standard
We were to use the discrete abstraction 
\begin_inset Formula $\nabla\text{²}\varphi:=(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²}=f(x,y)$
\end_inset

.
 We were permitted to calculate over a quadratic field with points divided
 up uniformly in both directions.
\end_layout

\begin_layout Chapter*
Analysis and Design
\end_layout

\begin_layout Standard
Starting from the discrete equation we were allowed to use I decided to
 use relaxation, as it's relatively straightforward and performs well under
 most circumstances.
\end_layout

\begin_layout Standard
In order to use a relaxation method we need an update rule.
 Taking a hint as to the desired result from Wikipedia's article on relaxation
 we perform a transformation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\\
\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y) & = & h\text{²}f(x,y)\nonumber \\
\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y) & = & 4\varphi(x,y)\nonumber \\
(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y))/4 & = & \varphi(x,y)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Using the relaxation strategy, we repeatedly set 
\begin_inset Formula $\varphi(x,y)$
\end_inset

 to be 
\begin_inset Formula $(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y))/4$
\end_inset

 until some convergence criterium is fulfilled.
\end_layout

\begin_layout Standard
So far so good.
 And for the Dirichlet boundary condition, we don't need any more analytics
 than this.
 The solution is straightforward.
 However, now remains the thorny issue on how to best enforce 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 for the Neumann boundary conditions.
 
\end_layout

\begin_layout Section*
Neumann Boundary Condition Enforcing
\end_layout

\begin_layout Standard
The first part (
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

) is straightforward, as we let that point be zero and never change it.
 There are some optimizations to be done near the origin, but they are just
 Enforcing 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

, however, proved very challenging.
 There are two particular cases that needs consideration:
\end_layout

\begin_layout Enumerate
The sides of the square
\end_layout

\begin_layout Enumerate
The corners of the square
\end_layout

\begin_layout Standard
Let ut consider each in isolation.
 
\end_layout

\begin_layout Standard
Corner options:
\end_layout

\begin_layout Enumerate
Designate the point nearest to the corner that can still be determined by
 the relaxation rule as special.
 Set the corner and the two neighboring points equal to this one.
 Let 
\begin_inset Formula $(x,y)$
\end_inset

 be the top right corner
\begin_inset Formula 
\begin{eqnarray*}
\varphi(x,y) & = & \varphi(x-h,y-h)\\
\varphi(x-h,y) & = & \varphi(x-h,y-h)\\
\varphi(x,y-h) & = & \varphi(x-h,y-h)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Enumerate
Since 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

, we can assume that 
\begin_inset Formula $\varphi$
\end_inset

 does not change much between the corner and its neighbors.
 We simply average (for top right corner: 
\begin_inset Formula $(x,y)=(max,max)$
\end_inset

):
\begin_inset Formula 
\begin{eqnarray*}
\varphi(max,max) & = & (\varphi(max-1,max)+\varphi(max,max-1)\varphi(max-1,max-1))/3
\end{eqnarray*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In the same way, we can say that the points near the origin will have 
\begin_inset Formula $\varphi$
\end_inset

 be pretty close to zero:
\begin_inset Formula 
\begin{eqnarray*}
\varphi(0,1) & = & 0\\
\varphi(1,0) & = & 0\\
\varphi(1,1) & = & 0
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Approximate 
\begin_inset Formula $\varphi(x,y)$
\end_inset

 to be quadratic in the corner.
 Since 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 we get that the two neighbours per direction of the boundary point are
 equal to each other, independent of the border point itself.
 Assuming (x,y) is in the top right corner (
\begin_inset Formula $(x,y)=(max,max)$
\end_inset

):
\begin_inset Formula 
\begin{eqnarray}
(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\\
(\varphi(x-h,y)+\varphi(x-h,y)+\varphi(x,y-h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\nonumber \\
(2\varphi(x-h,y)+2\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\nonumber \\
(2\varphi(x-h,y)+2\varphi(x,y-h)-h\text{²}f(x,y))/4 & = & \varphi(x,y)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We can use this to special effect on the origin, since we know that 
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

:
\begin_inset Formula 
\begin{eqnarray*}
(2\varphi(h,0)+2\varphi(0,h)-h\text{²}f(0,0))/4 & = & 0\\
2\varphi(h,0)+2\varphi(0,h)-h\text{²}f(0,0) & = & 0\\
\varphi(h,0) & = & (h\text{²}f(0,0)-2\varphi(0,h))/2\\
\varphi(0,h) & = & (h\text{²}f(0,0)-2\varphi(h,0))/2
\end{eqnarray*}

\end_inset

This is circular, though, and makes the two right-angle neighbors to the
 origin completely independent of the rest of the matrix, which is clearly
 unfortunate.
 No satisfying solution was found.
\end_layout

\end_deeper
\begin_layout Standard
Side options:
\end_layout

\begin_layout Enumerate
Approximate 
\begin_inset Formula $\varphi(x,y)$
\end_inset

 to be linear on the border.
 Since 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 we get that the two neighbours in the 
\begin_inset Formula $n$
\end_inset

 direction of a boundary point are equal to that point.
 This changes the math from (1) a bit.
 Assuming (x,y) is on the left border(
\begin_inset Formula $x=0$
\end_inset

):
\begin_inset Formula 
\begin{eqnarray}
(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\\
(\varphi(x,y)+\varphi(x,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\nonumber \\
(\varphi(x,y+h)+\varphi(x,y-h)-2\varphi(x,y))/h\text{²} & = & f(x,y)\nonumber \\
\varphi(x,y+h)+\varphi(x,y-h)-2\varphi(x,y) & = & h\text{²}f(x,y)\nonumber \\
\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y) & = & 2\varphi(x,y)\nonumber \\
(\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y))/2 & = & \varphi(x,y)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Optionally, we can say that, in order for this to be consistent with how
 the in-memory matrix actually looks, the boundary point's neighbor inside
 the matrix is updated along with the boundary point.
 This means that, for 
\begin_inset Formula $x=0$
\end_inset

, after updating 
\begin_inset Formula $\varphi(x+h,y)==\varphi(x,y)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Approximate 
\begin_inset Formula $\varphi(x,y)$
\end_inset

 to be quadratic on the border.
 Since 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 we get that the two neighbours in the 
\begin_inset Formula $n$
\end_inset

 direction of a boundary point are equal to each other, independent of the
 border point itself.
 Assuming (x,y) is on the left border(
\begin_inset Formula $x=0$
\end_inset

):
\begin_inset Formula 
\begin{eqnarray}
(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\\
(\varphi(x+h,y)+\varphi(x+h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\nonumber \\
(2\varphi(x+h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\nonumber \\
2\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y) & = & h\text{²}f(x,y)\nonumber \\
2\varphi(x+h,y)+\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y) & = & 4\varphi(x,y)\nonumber \\
(2\varphi(x+h,y)+\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y))/4 & = & \varphi(x,y)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Section*
Analytical Solutions
\end_layout

\begin_layout Standard
For the first task (the Dirichlet one) we need 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\nabla\text{²}\varphi=1$
\end_inset

in general and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\varphi(x,y)=\frac{1}{4}(x\text{²}+y\text{²})$
\end_inset

 on the boundary.
 Turns out that 
\begin_inset Formula $\varphi(x,y)=\frac{1}{4}(x\text{²}+y\text{²})$
\end_inset

 satisfies both.
\end_layout

\begin_layout Standard
For the second task (first Neumann one) we need 
\begin_inset Formula $\nabla\text{²}\varphi=12-12x-12y$
\end_inset

 generally, 
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

 and 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 on boundary.
 With some trial and error, it can be determined that 
\begin_inset Formula $3x\text{²}+3y\text{²}-2x\text{³}-2y\text{³}$
\end_inset

 satisfies those.
\end_layout

\begin_layout Standard
For the third task (second Neumann one) we need 
\begin_inset Formula $\nabla\text{²}\varphi=(6-12x)(3y\text{²}-2y\text{³})+(3x\text{²}-2x\text{³})(6-12y)$
\end_inset

 generally, 
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

 and 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 on boundary.
 This seems like a very hard nut to crack until you realise that:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
(6-12x)(3y\text{²}-2y\text{³})+(3x\text{²}-2x\text{³})(6-12y)=\frac{\delta\text{²}i}{\delta x\text{²}}j+i\frac{\delta\text{²}j}{\delta y\text{²}}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
and that
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\nabla\text{²}(ij) & = & \frac{\delta\text{²}ij}{\delta x\text{²}}+\frac{\delta\text{²}ij}{\delta y\text{²}}\\
\nabla\text{²}(ij) & = & \frac{\delta\text{²}i}{\delta x\text{²}}j+i\frac{\delta\text{²}j}{\delta x\text{²}}+\frac{\delta\text{²}i}{\delta y\text{²}}j+i\frac{\delta\text{²}j}{\delta y\text{²}}+2\frac{\delta i}{\delta x}\frac{\delta j}{\delta x}+2\frac{\delta i}{\delta y}\frac{\delta j}{\delta y}
\end{eqnarray}

\end_inset

Here all the terms reduce to 
\begin_inset Formula $0$
\end_inset

 except 
\begin_inset Formula $\frac{\delta\text{²}i}{\delta x\text{²}}j+i\frac{\delta\text{²}j}{\delta y\text{²}}$
\end_inset

, which means, together with the other requirements, that 
\begin_inset Formula $\varphi(x,y)=(3y\text{²}-2y\text{³})(3x\text{²}-2x\text{³})$
\end_inset

.
\end_layout

\begin_layout Section*
Memory use
\end_layout

\begin_layout Standard
No memory is allocated dynamically and only the matrix holding the values
 itself has a size that depends on inter-point distance.
 In terms of big-O notation, memory use is O(1/h²), where h is the inter-point
 distance.
 An interesting note is that, as the matrix is the main source of memory
 consumption, setting real to be 8 bytes means memory consumption roughly
 doubles.
\end_layout

\begin_layout Section*
Convergence criterium
\end_layout

\begin_layout Standard
There were many possible ones to consider
\end_layout

\begin_layout Enumerate
Setting a minimum permitted ratio of current average change to previous
 average change
\end_layout

\begin_layout Enumerate
Setting a minimum permitted ratio of current maximum change to previous
 maximum change
\end_layout

\begin_layout Enumerate
For Neumann: Using the fact that we know points close to origin to be close
 to zero, we can say that we want (1,1) to be closer to zero than a certain
 difference.
\end_layout

\begin_layout Enumerate
Setting a minimum permitted ratio of current average change to previous
 average change
\end_layout

\begin_layout Chapter*
Implementation
\end_layout

\begin_layout Standard
List of functions and description of each:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the right side of the poisson equation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ANALYTICAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computes the analytical solution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SIMPLEESTIMATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computes a new estimate for the value of (x*h,y*h).
 Not valid on the boundary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NEWESTIMATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computes the value of ((x-1)*h,(y-h)*h).
 Valid everywhere.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HIGHESTCHANGEFUN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the gighest change in (phi-)value given a new old value, new assignment
 and the previous highest change
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOWCHANGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the lesser of two variables.
 Intended to compare change magnitudes to determine the lowest one.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ANALYTICALERROR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computes the analytically determined average squared error
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Here is the most interesting code, which is for the Neumann case
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FUNCTION NEWESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

  !computes the value of ((x-1)*h,(y-h)*h).
 Valid everywhere.
\end_layout

\begin_layout Plain Layout

  INTEGER X
\end_layout

\begin_layout Plain Layout

  INTEGER  Y
\end_layout

\begin_layout Plain Layout

  REAL H
\end_layout

\begin_layout Plain Layout

  INTEGER LENGTH
\end_layout

\begin_layout Plain Layout

  REAL NEWVALUE
\end_layout

\begin_layout Plain Layout

  REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout

  REAL NEWESTIMATE
\end_layout

\begin_layout Plain Layout

  REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout

  REAL F
\end_layout

\begin_layout Plain Layout

  REAL :: ORIGINDEMAND
\end_layout

\begin_layout Plain Layout

  IF (X==1 .AND.
 Y==1) THEN
\end_layout

\begin_layout Plain Layout

    PHIS(1,2)=0.0
\end_layout

\begin_layout Plain Layout

    PHIS(2,1)=0.0
\end_layout

\begin_layout Plain Layout

    PHIS(2,2)=0.0
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE=0.0
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==1 .AND.
 Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (PHIS(2,LENGTH-1) + PHIS(2,LENGTH) + PHIS(1,LENGTH-1))/3.0
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==LENGTH .AND.
 Y==1) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (PHIS(LENGTH-1,2) + PHIS(LENGTH,2) + PHIS(LENGTH-1,1))/3.0
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==LENGTH .AND.
 Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (PHIS(LENGTH-1,LENGTH-1) + PHIS(LENGTH-1,LENGTH) + PHIS(LENGTH
,LENGTH-1))/3.0
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==1) THEN
\end_layout

\begin_layout Plain Layout

    NEWVALUE = (1.0/4.0)*(2*PHIS(X+1,Y)+PHIS(X,Y+1)+PHIS(X,Y-1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = NEWVALUE
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==LENGTH) THEN
\end_layout

\begin_layout Plain Layout

    NEWVALUE = (1.0/4.0)*(PHIS(X,Y+1)+2*PHIS(X-1,Y)+PHIS(X,Y-1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = NEWVALUE
\end_layout

\begin_layout Plain Layout

  ELSE IF (Y==1) THEN
\end_layout

\begin_layout Plain Layout

    NEWVALUE = (1.0/4.0)*(PHIS(X+1,Y)+2*PHIS(X,Y+1)+PHIS(X-1,Y)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = NEWVALUE
\end_layout

\begin_layout Plain Layout

  ELSE IF (Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout

    NEWVALUE = (1.0/4.0)*(PHIS(X+1,Y)+PHIS(X-1,Y)+2*PHIS(X,Y-1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = NEWVALUE
\end_layout

\begin_layout Plain Layout

  ELSE
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = SIMPLEESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

  END IF
\end_layout

\begin_layout Plain Layout

  RETURN
\end_layout

\begin_layout Plain Layout

END FUNCTION
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FUNCTION SIMPLEESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

  !computes a new estimate for the value of (x*h,y*h).
 Not valid on the boundary
\end_layout

\begin_layout Plain Layout

  INTEGER X,Y
\end_layout

\begin_layout Plain Layout

  REAL H
\end_layout

\begin_layout Plain Layout

  REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout

  INTEGER LENGTH
\end_layout

\begin_layout Plain Layout

  REAL F
\end_layout

\begin_layout Plain Layout

  REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout

  SIMPLEESTIMATE = (1.0/4.0)*(PHIS(X+1,Y)+PHIS(X,Y+1)+PHIS(X-1,Y)+PHIS(X,Y-1)-H*H*
F(X,Y,H))
\end_layout

\begin_layout Plain Layout

  RETURN
\end_layout

\begin_layout Plain Layout

END FUNCTION
\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Testing
\end_layout

\begin_layout Standard
In the end it turned out that whether you approximates the phi at the boundary
 as being linear or quadratic has little effect.
 On, the corners, however, simple averaging gives markedly superior results.
 Setting the four points at the origin and closest to it to zero at each
 iteration start is also a 
\end_layout

\begin_layout Standard
Here's time taken and accuracy(average squared error) for the best boundary
 approach using the second Neumann task.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
distance between points
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time / accuracy
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0m0.012s / 9.9817812014075917E-005
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1m46.588s / 5.8456351344354158E-009
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Chapter*
Conclusion, Evaluation and Further Work
\end_layout

\begin_layout Chapter
\start_of_appendix
System manual
\end_layout

\begin_layout Chapter
User manual
\end_layout

\begin_layout Chapter
Test results
\end_layout

\begin_layout Chapter
Code listing
\end_layout

\end_body
\end_document

#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\lstset{
numbers=left,
frame=single
breaklines=true}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 0.2cm
\topmargin 1cm
\rightmargin 0.2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Author
Tormod Gjeitnes Hellen
\end_layout

\begin_layout Title
TMR4160 Project Report
\end_layout

\begin_layout Chapter*
Introduction
\end_layout

\begin_layout Standard
The task given was to numerically solve the Poisson equation under Dirichlet
 and Neumann boundary conditions.
 The Dirichlet case was pretty straightforward to implement and performed
 pretty well on first try.
 In the Neumann case interperting the boundary condition (that the derivative
 normally over the boundary is 0) proved very challenging and frustrating.
\end_layout

\begin_layout Standard
Another source of error was that arrays are 1-indexed, which matters when
 you're trying to determine the coordinates from the matrix index.
\end_layout

\begin_layout Chapter*
Background
\end_layout

\begin_layout Standard
The problem presented is to numerically solve the two-dimensional Poisson
 equation 
\begin_inset Formula $\nabla\text{²}\varphi:=\frac{\delta\text{²}\varphi}{\delta x\text{²}}+\frac{\delta\text{²}\varphi}{\delta y\text{²}}=f(x,y)$
\end_inset

( find 
\begin_inset Formula $\varphi$
\end_inset

) under three different conditions
\end_layout

\begin_layout Enumerate
With 
\begin_inset Formula $f(x,y)=1$
\end_inset

 generally and 
\begin_inset Formula $\varphi(x,y)=\frac{1}{4}(x\text{²}+y\text{²})$
\end_inset

 on the boundary(Dirichlet condition)
\end_layout

\begin_layout Enumerate
With 
\begin_inset Formula $f(x,y)=12-12x-12y$
\end_inset

 generally, 
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

 and 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 on the boundary(Neumann condition), where 
\begin_inset Formula $n$
\end_inset

 is a vector normal to the boundary.
\end_layout

\begin_layout Enumerate
With 
\begin_inset Formula $f(x,y)=(6-12x)(3y\text{²}-2y\text{³})+(3x\text{²}-2x\text{³})(6-12y)$
\end_inset

 generally, 
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

 and 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 on the boundary(Neumann condition), where 
\begin_inset Formula $n$
\end_inset

 is a vector normal to the boundary.
\end_layout

\begin_layout Standard
We were to use the discrete abstraction 
\begin_inset Formula $\nabla\text{²}\varphi:=(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²}=f(x,y)$
\end_inset

.
 We were permitted to calculate over a quadratic field with points divided
 up uniformly in both directions.
\end_layout

\begin_layout Chapter*
Analysis and Design
\end_layout

\begin_layout Standard
Starting from the discrete equation we were allowed to use I decided to
 use relaxation, as it's relatively straightforward and performs well under
 most circumstances.
\end_layout

\begin_layout Standard
In order to use a relaxation method we need an update rule.
 Taking a hint as to the desired result from Wikipedia's article on relaxation
 we perform a transformation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\\
\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y) & = & h\text{²}f(x,y)\nonumber \\
\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y) & = & 4\varphi(x,y)\nonumber \\
(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y))/4 & = & \varphi(x,y)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Using the relaxation strategy, we repeatedly set 
\begin_inset Formula $\varphi(x,y)$
\end_inset

 to be 
\begin_inset Formula $(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y))/4$
\end_inset

 until some convergence criterium is fulfilled.
\end_layout

\begin_layout Standard
So far so good.
 And for the Dirichlet boundary condition, we don't need any more analytics
 than this.
 The solution is straightforward.
 However, now remains the thorny issue on how to best enforce 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 for the Neumann boundary conditions.
 
\end_layout

\begin_layout Section*
Neumann Boundary Condition Enforcing
\end_layout

\begin_layout Standard
The first part (
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

) is straightforward, as we let that point be zero and never change it.
 There are some optimizations to be done near the origin, but they are just
 Enforcing 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

, however, proved very challenging.
 There are two particular cases that needs consideration:
\end_layout

\begin_layout Enumerate
The sides of the square
\end_layout

\begin_layout Enumerate
The corners of the square
\end_layout

\begin_layout Standard
Let ut consider each in isolation.
 
\end_layout

\begin_layout Standard
Side options:
\end_layout

\begin_layout Enumerate
Approximate 
\begin_inset Formula $\varphi(x,y)$
\end_inset

 to be linear on the border, assuming that the outer points (
\begin_inset Formula $x=1$
\end_inset

 etc.) are the border.
 Since 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 we get that the two neighbours in the 
\begin_inset Formula $n$
\end_inset

 direction of a boundary point are equal to that point.
 This changes the math from (1) a bit.
 Assuming (x,y) is on the left border(
\begin_inset Formula $x=0$
\end_inset

):
\begin_inset Formula 
\begin{eqnarray}
(\varphi(x+h,y)+\varphi(x-h,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\\
(\varphi(x,y)+\varphi(x,y)+\varphi(x,y+h)+\varphi(x,y-h)-4\varphi(x,y))/h\text{²} & = & f(x,y)\nonumber \\
(\varphi(x,y+h)+\varphi(x,y-h)-2\varphi(x,y))/h\text{²} & = & f(x,y)\nonumber \\
\varphi(x,y+h)+\varphi(x,y-h)-2\varphi(x,y) & = & h\text{²}f(x,y)\nonumber \\
\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y) & = & 2\varphi(x,y)\nonumber \\
(\varphi(x,y+h)+\varphi(x,y-h)-h\text{²}f(x,y))/2 & = & \varphi(x,y)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Optionally, we can say that, in order for this to be consistent with how
 the in-memory matrix actually looks, the boundary point's neighbor inside
 the matrix is updated along with the boundary point.
 This means that, for 
\begin_inset Formula $x=0$
\end_inset

, after updating 
\begin_inset Formula $\varphi(x+h,y)==\varphi(x,y)$
\end_inset

.
\end_layout

\begin_layout Itemize
This means that the amount of points in any of the two directions is 
\begin_inset Formula $\frac{1}{h}+1$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Approximate 
\begin_inset Formula $\varphi(x,y)$
\end_inset

 to be linear on the border, assuming that the border lies next to the outer
 points (
\begin_inset Formula $x=h/2$
\end_inset

 etc.).
 This deviates from the approach hitherto taken in this report, as this
 idea came fairly late.
 Since 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 we get that the two neighbours in the 
\begin_inset Formula $n$
\end_inset

 direction of a boundary point are equal to that point.
 This changes the result in (3).
 Assuming (x,y) is on the left border(
\begin_inset Formula $x=h/2$
\end_inset

):
\begin_inset Formula 
\begin{eqnarray*}
(\varphi(x,y+h)+\varphi(x,y-h)+\varphi(x+h,y)-h\text{²}f(x,y))/3 & = & \varphi(x,y)
\end{eqnarray*}

\end_inset

Let this be the OUTERBORDER strategy
\end_layout

\begin_deeper
\begin_layout Itemize
This means that the amount of points in any of the two directions is 
\begin_inset Formula $length=\frac{1}{h}$
\end_inset

.
 We can derive this from
\begin_inset Formula 
\begin{eqnarray*}
h & = & \frac{1-2\frac{h}{2}}{length-1}\\
length-1 & = & \frac{1-2\frac{h}{2}}{h}\\
length & = & \frac{1-2\frac{h}{2}}{h}+1\\
length & = & \frac{1-h}{h}+\frac{h}{h}\\
length & = & \frac{1}{h}
\end{eqnarray*}

\end_inset

Explanation: At the right-hand side we see
\end_layout

\begin_deeper
\begin_layout Itemize
1: This is the distance between the borders
\end_layout

\begin_layout Itemize
\begin_inset Formula $2\frac{h}{2}$
\end_inset

: This is the distance lost because the two outer points each need 
\begin_inset Formula $\frac{h}{2}$
\end_inset

 units of distance between themselves and the border
\end_layout

\begin_layout Itemize
\begin_inset Formula $length-1$
\end_inset

: 
\begin_inset Quotes eld
\end_inset

length
\begin_inset Quotes erd
\end_inset

 is the amount of points in a direction.
 We subtract one because if you part a bread in three, there will be only
 two closest-piece-to-closest-piece distances between them if you line them
 up.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Corner options:
\end_layout

\begin_layout Enumerate
Designate the point nearest to the corner that can still be determined by
 the relaxation rule as special.
 Set the corner and the two neighboring points equal to this one.
 Let 
\begin_inset Formula $(x,y)$
\end_inset

 be the top right corner
\begin_inset Formula 
\begin{eqnarray*}
\varphi(x,y) & = & \varphi(x-h,y-h)\\
\varphi(x-h,y) & = & \varphi(x-h,y-h)\\
\varphi(x,y-h) & = & \varphi(x-h,y-h)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Enumerate
Since 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

, we can assume that 
\begin_inset Formula $\varphi$
\end_inset

 does not change much between the corner and its neighbors.
 We simply average (for top right corner: 
\begin_inset Formula $(x,y)=(max,max)$
\end_inset

):
\begin_inset Formula 
\begin{eqnarray*}
\varphi(max,max) & = & (\varphi(max-1,max)+\varphi(max,max-1)\varphi(max-1,max-1))/3
\end{eqnarray*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In the same way, we can say that the points near the origin will have 
\begin_inset Formula $\varphi$
\end_inset

 be pretty close to zero and we can set this at the start of each iteration:
\begin_inset Formula 
\begin{eqnarray*}
\varphi(0,h) & = & 0\\
\varphi(h,0) & = & 0\\
\varphi(h,h) & = & 0
\end{eqnarray*}

\end_inset

Let this be the RESET strategy
\end_layout

\end_deeper
\begin_layout Enumerate
In accordance with the OUTERBORDER strategy outlined above, we handle the
 corners similarly.
 For the upper right corner (
\begin_inset Formula $\varphi(1-h/2,1-h/2)$
\end_inset

):
\begin_inset Formula 
\[
\varphi(x,y)=(\varphi(x-h,y)+\varphi(x,y-h)-h\text{²}f(x,y))/2
\]

\end_inset


\end_layout

\begin_layout Section*
Analytical Solutions
\end_layout

\begin_layout Standard
For the first task (the Dirichlet one) we need 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\nabla\text{²}\varphi=1$
\end_inset

in general and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\varphi(x,y)=\frac{1}{4}(x\text{²}+y\text{²})$
\end_inset

 on the boundary.
 Turns out that 
\begin_inset Formula $\varphi(x,y)=\frac{1}{4}(x\text{²}+y\text{²})$
\end_inset

 satisfies both.
\end_layout

\begin_layout Standard
For the second task (first Neumann one) we need 
\begin_inset Formula $\nabla\text{²}\varphi=12-12x-12y$
\end_inset

 generally, 
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

 and 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 on boundary.
 With some trial and error, it can be determined that 
\begin_inset Formula $3x\text{²}+3y\text{²}-2x\text{³}-2y\text{³}$
\end_inset

 satisfies those.
\end_layout

\begin_layout Standard
For the third task (second Neumann one) we need 
\begin_inset Formula $\nabla\text{²}\varphi=(6-12x)(3y\text{²}-2y\text{³})+(3x\text{²}-2x\text{³})(6-12y)$
\end_inset

 generally, 
\begin_inset Formula $\varphi(0,0)=0$
\end_inset

 and 
\begin_inset Formula $\frac{d\varphi}{dn}=0$
\end_inset

 on boundary.
 This seems like a very hard nut to crack until you realise that:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
(6-12x)(3y\text{²}-2y\text{³})+(3x\text{²}-2x\text{³})(6-12y)=\frac{\delta\text{²}i}{\delta x\text{²}}j+i\frac{\delta\text{²}j}{\delta y\text{²}}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
and that
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\nabla\text{²}(ij) & = & \frac{\delta\text{²}ij}{\delta x\text{²}}+\frac{\delta\text{²}ij}{\delta y\text{²}}\\
\nabla\text{²}(ij) & = & \frac{\delta\text{²}i}{\delta x\text{²}}j+i\frac{\delta\text{²}j}{\delta x\text{²}}+\frac{\delta\text{²}i}{\delta y\text{²}}j+i\frac{\delta\text{²}j}{\delta y\text{²}}+2\frac{\delta i}{\delta x}\frac{\delta j}{\delta x}+2\frac{\delta i}{\delta y}\frac{\delta j}{\delta y}
\end{eqnarray}

\end_inset

Here all the terms reduce to 
\begin_inset Formula $0$
\end_inset

 except 
\begin_inset Formula $\frac{\delta\text{²}i}{\delta x\text{²}}j+i\frac{\delta\text{²}j}{\delta y\text{²}}$
\end_inset

, which means, together with the other requirements, that 
\begin_inset Formula $\varphi(x,y)=(3y\text{²}-2y\text{³})(3x\text{²}-2x\text{³})$
\end_inset

.
\end_layout

\begin_layout Section*
Memory use
\end_layout

\begin_layout Standard
No memory is allocated dynamically and only the matrix holding the values
 itself has a size that depends on inter-point distance.
 In terms of big-O notation, memory use is O(1/h²), where h is the inter-point
 distance.
 An interesting note is that, as the matrix is the main source of memory
 consumption, setting real to be 8 bytes means memory consumption roughly
 doubles.
\end_layout

\begin_layout Section*
Convergence criterium
\end_layout

\begin_layout Standard
There were many possible ones to consider
\end_layout

\begin_layout Enumerate
Setting a minimum permitted ratio of current average change to previous
 average change
\end_layout

\begin_layout Enumerate
Setting a minimum permitted ratio of current maximum change to previous
 maximum change
\end_layout

\begin_layout Enumerate
For Neumann: Using the fact that we know points close to origin to be close
 to zero, we can say that we want (1,1) to be closer to zero than a certain
 difference.
\end_layout

\begin_layout Enumerate
Observing that for 1 and 2, the changes cannot be permitted to rise, they
 can be combined and measure both of these and let none of them rise
\end_layout

\begin_layout Enumerate
Modifying 4, the all time lows of average change and maximum change is tracked,
 and a minimum permitted ratio for each current of these two to the all
 time low developed.
 If both are breached at the same time, the algorithm is said to have converged.
\end_layout

\begin_layout Chapter*
Implementation
\end_layout

\begin_layout Standard
List of functions and description of each:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the right side of the poisson equation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ANALYTICAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computes the analytical solution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SIMPLEESTIMATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computes a new estimate for the value of (x*h,y*h).
 Not valid on the boundary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NEWESTIMATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computes the value of ((x-1)*h,(y-h)*h).
 Valid everywhere.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HIGHESTCHANGEFUN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the highest change in (phi-)value given new old value, new assignment
 and previous highest change
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOWCHANGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the lesser of two variables.
 Intended to compare change magnitudes to determine the lowest one.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ANALYTICALERROR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computes the analytically determined average squared error
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Here is the most interesting code, which is for the Neumann case
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

FUNCTION NEWESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

  !computes the value of ((x-1)*h,(y-h)*h).
 Valid everywhere.
\end_layout

\begin_layout Plain Layout

  INTEGER X
\end_layout

\begin_layout Plain Layout

  INTEGER  Y
\end_layout

\begin_layout Plain Layout

  REAL H
\end_layout

\begin_layout Plain Layout

  INTEGER LENGTH
\end_layout

\begin_layout Plain Layout

  REAL NEWVALUE
\end_layout

\begin_layout Plain Layout

  REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout

  REAL NEWESTIMATE
\end_layout

\begin_layout Plain Layout

  REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout

  REAL F
\end_layout

\begin_layout Plain Layout

  IF (X==1 .AND.
 Y==1) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = 0.0
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==1 .AND.
 Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (1.0/2.0)*(PHIS(X+1,Y)+PHIS(X,Y-1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==LENGTH .AND.
 Y==1) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (1.0/2.0)*(PHIS(X-1,Y)+PHIS(X,Y+1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==LENGTH .AND.
 Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (1.0/2.0)*(PHIS(X-1,Y)+PHIS(X,Y-1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==1) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (1.0/3.0)*(PHIS(X,Y+1)+PHIS(X,Y-1)+PHIS(X+1,Y)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

  ELSE IF (X==LENGTH) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (1.0/3.0)*(PHIS(X,Y+1)+PHIS(X,Y-1)+PHIS(X-1,Y)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

  ELSE IF (Y==1) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (1.0/3.0)*(PHIS(X+1,Y)+PHIS(X-1,Y)+PHIS(X,Y+1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

  ELSE IF (Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = (1.0/3.0)*(PHIS(X+1,Y)+PHIS(X-1,Y)+PHIS(X,Y-1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

  ELSE
\end_layout

\begin_layout Plain Layout

    NEWESTIMATE = SIMPLEESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

  END IF
\end_layout

\begin_layout Plain Layout

  RETURN
\end_layout

\begin_layout Plain Layout

END FUNCTION
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FUNCTION SIMPLEESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

  !computes a new estimate for the value of (x*h,y*h).
 Not valid on the boundary
\end_layout

\begin_layout Plain Layout

  INTEGER X,Y
\end_layout

\begin_layout Plain Layout

  REAL H
\end_layout

\begin_layout Plain Layout

  REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout

  INTEGER LENGTH
\end_layout

\begin_layout Plain Layout

  REAL F
\end_layout

\begin_layout Plain Layout

  REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout

  SIMPLEESTIMATE = (1.0/4.0)*(PHIS(X+1,Y)+PHIS(X,Y+1)+PHIS(X-1,Y)+PHIS(X,Y-1)-H*H*
F(X,Y,H))
\end_layout

\begin_layout Plain Layout

  RETURN
\end_layout

\begin_layout Plain Layout

END FUNCTION
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the main loop:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Fortran"
inline false
status open

\begin_layout Plain Layout

NUMITERATIONS = 0
\end_layout

\begin_layout Plain Layout

  !the actual computation is performed here
\end_layout

\begin_layout Plain Layout

  DO WHILE ((LOWHIGHESTCHANGE/HIGHESTCHANGE) > 1.1 .OR.
 (LOWAVGCHANGE/AVGCHANGE) > 1.000008)
\end_layout

\begin_layout Plain Layout

    NUMITERATIONS = NUMITERATIONS + 1
\end_layout

\begin_layout Plain Layout

    LOWAVGCHANGE = LOWCHANGE(LOWAVGCHANGE, AVGCHANGE)
\end_layout

\begin_layout Plain Layout

    LOWHIGHESTCHANGE = LOWCHANGE(LOWHIGHESTCHANGE, HIGHESTCHANGE)
\end_layout

\begin_layout Plain Layout

    HIGHESTCHANGE = 0.0
\end_layout

\begin_layout Plain Layout

    AVGCHANGE = 0.0
\end_layout

\begin_layout Plain Layout

    DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout

      DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout

          NEWVALUE = NEWESTIMATE(I,J,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

          HIGHESTCHANGE = HIGHESTCHANGEFUN(PHIS(I,J),NEWVALUE,HIGHESTCHANGE)
\end_layout

\begin_layout Plain Layout

          AVGCHANGE = AVGCHANGE + ((PHIS(I,J)-NEWVALUE)**2)/SIZE
\end_layout

\begin_layout Plain Layout

          PHIS(I,J) = NEWVALUE
\end_layout

\begin_layout Plain Layout

      END DO
\end_layout

\begin_layout Plain Layout

    END DO
\end_layout

\begin_layout Plain Layout

    !WRITE (*,*) "HIGHESTCHANGE IS ", HIGHESTCHANGE
\end_layout

\begin_layout Plain Layout

    !WRITE (*,*) "AVGCHANGE IS ", AVGCHANGE
\end_layout

\begin_layout Plain Layout

    !WRITE (*,*) "LOWAVGCHANGE IS ", LOWAVGCHANGE
\end_layout

\begin_layout Plain Layout

    !WRITE (*,*) "LOWHIGHESTCHANGE IS ", LOWHIGHESTCHANGE
\end_layout

\begin_layout Plain Layout

    !WRITE (*,*) ""
\end_layout

\begin_layout Plain Layout

  END DO
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The display code is almost entirely taken from the Mesa project's 
\begin_inset Quotes eld
\end_inset

array
\begin_inset Quotes erd
\end_inset

 example.
 What's changed is the function that gets the height of the points
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

static float
\end_layout

\begin_layout Plain Layout

getinm(float x, float y, float minx, float maxx, float miny, float maxy)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int i = ((x+(-minx))/(maxx-minx))*LENGTH;
\end_layout

\begin_layout Plain Layout

  int j = ((y+(-miny))/(maxy-miny))*LENGTH;
\end_layout

\begin_layout Plain Layout

  int index = i*LENGTH+j;
\end_layout

\begin_layout Plain Layout

  if(index<0){index=0;}
\end_layout

\begin_layout Plain Layout

  if(index>LENGTH*LENGTH){index=LENGTH*LENGTH-1;}
\end_layout

\begin_layout Plain Layout

  //printf("x is %f, y is %f, i is %d, j is %d, index is %d
\backslash
n",x,y,i,j,index);            //disabled for better performance
\end_layout

\begin_layout Plain Layout

  return inm[index];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the start of the main function, which reads in the data:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

int
\end_layout

\begin_layout Plain Layout

main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  srand(time(NULL));
\end_layout

\begin_layout Plain Layout

  float in = 0.0;
\end_layout

\begin_layout Plain Layout

  int control = 0;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  FILE *f = fopen("results.txt", "r");
\end_layout

\begin_layout Plain Layout

  fscanf(f,"%d",&LENGTH);
\end_layout

\begin_layout Plain Layout

  fscanf(f,"%d",&control);
\end_layout

\begin_layout Plain Layout

  assert(LENGTH==control);
\end_layout

\begin_layout Plain Layout

  float arr[LENGTH*LENGTH];
\end_layout

\begin_layout Plain Layout

  inm = &arr;
\end_layout

\begin_layout Plain Layout

  for(int i=0; i<LENGTH*LENGTH; i++)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    fscanf(f,"%f",&in);
\end_layout

\begin_layout Plain Layout

    inm[i] = in;
\end_layout

\begin_layout Plain Layout

    //inm[i] = rand()%GLmaxdiff;
\end_layout

\begin_layout Plain Layout

    if (in < lowest)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      lowest = in;
\end_layout

\begin_layout Plain Layout

    } 
\end_layout

\begin_layout Plain Layout

    else if (in > highest)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      highest = in;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    //printf("%f
\backslash
n", in);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  fclose(f);
\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Testing
\end_layout

\begin_layout Standard
In the end, the OUTERBORDER strategy is markedly superior to anything else
 by a solid margin.
 For a convergence criterium, we settled on option 5 from above.
\end_layout

\begin_layout Standard
For small inter-point distances, the neumann programs are really slow.
 A possible reason is that the constant point at the origin must have the
 consequences of its value propagated through the matrix and this requires
 more iterations, even as each iteration becomes more costly.
 In the graph below we set the average squared error to be 0.1 and see how
 long it needs to run to achieve this.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename performance.svg
	lyxscale 10
	width 70text%

\end_inset


\end_layout

\begin_layout Chapter*
Conclusion, Evaluation and Further Work
\end_layout

\begin_layout Standard
A possible way to speed up the algorithm would be to first do a run with
 large inter-point distance, and then use the result to initialize the bigger
 matrix.
 Unfortunately this has not been tried during the work with this report.
 I am a bit unsure about the convergence criterium, but I have no better
 suggestions.
\end_layout

\begin_layout Chapter
\start_of_appendix
User manual
\end_layout

\begin_layout Standard
To compile and run the Neumann case, use 
\begin_inset Quotes eld
\end_inset

gfortran neumannFinal.f95 -fimplicit-none -O3 -o neumannFinal -fdefault-real-8
 && time ./neumannFinal
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Remember to comment in or out the correct f and analytical functions!
\end_layout

\begin_layout Standard
To compile and run the Dirichlet case, use 
\begin_inset Quotes eld
\end_inset

gfortran dirichlet.f95 -fimplicit-none -O3 -o dirichlet -fdefault-real-8
 && time ./dirichlet
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
To compile the display program use 
\begin_inset Quotes eld
\end_inset

clang -o array array.c shaderutil.c -lGL -lglut -lm -lGLEW -O3
\begin_inset Quotes erd
\end_inset

.
 To run it, be in the same folder as the result.txt file and use 
\begin_inset Quotes eld
\end_inset

./array
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

./array/array
\begin_inset Quotes erd
\end_inset

 depending on where the executable is.
 Use of Clang is of course optional - GCC should work as well.
\end_layout

\begin_layout Chapter
Code listing
\end_layout

\begin_layout Standard
Neumann(neumannFinal.f95):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
!gfortran neumannFinal.f95 -fimplicit-none -O3 -o neumannFinal -fdefault-real-8
 && time ./neumannFinal
\end_layout

\begin_layout Plain Layout
      
\end_layout

\begin_layout Plain Layout
      FUNCTION F(X,Y,H)
\end_layout

\begin_layout Plain Layout
        !the right side of the poisson equation
\end_layout

\begin_layout Plain Layout
        INTEGER X,Y
\end_layout

\begin_layout Plain Layout
        REAL H
\end_layout

\begin_layout Plain Layout
        REAL F
\end_layout

\begin_layout Plain Layout
        REAL :: XC
\end_layout

\begin_layout Plain Layout
        REAL :: YC
\end_layout

\begin_layout Plain Layout
        XC = (X-0.5)*H
\end_layout

\begin_layout Plain Layout
        YC = (Y-0.5)*H
\end_layout

\begin_layout Plain Layout
        !F=12-12*XC-12*YC                                              
        !Switch which of these are commented out if you wish to use the
 other divergence function
\end_layout

\begin_layout Plain Layout
        F=(6-12*XC)*(3*YC**2-2*YC**3) + (3*XC**2-2*XC**3)*(6-12*YC)
\end_layout

\begin_layout Plain Layout
        RETURN
\end_layout

\begin_layout Plain Layout
      END FUNCTION
\end_layout

\begin_layout Plain Layout
           
\end_layout

\begin_layout Plain Layout
      FUNCTION ANALYTICAL(X,Y,H)
\end_layout

\begin_layout Plain Layout
        !computes the analytical solution
\end_layout

\begin_layout Plain Layout
        REAL ANALYTICAL
\end_layout

\begin_layout Plain Layout
        INTEGER :: X
\end_layout

\begin_layout Plain Layout
        INTEGER :: Y
\end_layout

\begin_layout Plain Layout
        REAL :: H
\end_layout

\begin_layout Plain Layout
        REAL :: XC
\end_layout

\begin_layout Plain Layout
        REAL :: YC
\end_layout

\begin_layout Plain Layout
        XC = (X-0.5)*H
\end_layout

\begin_layout Plain Layout
        YC = (Y-0.5)*H
\end_layout

\begin_layout Plain Layout
        !ANALYTICAL = 3*XC**2 + 3*YC**2 - 2*XC**3 - 2*YC**3            
       !Switch which of these are commented out if you wish to use the other
 divergence function
\end_layout

\begin_layout Plain Layout
        ANALYTICAL = (3*YC**2 - 2*YC**3)*(3*XC**2 - 2*XC**3)
\end_layout

\begin_layout Plain Layout
        RETURN
\end_layout

\begin_layout Plain Layout
      END FUNCTION
\end_layout

\begin_layout Plain Layout
      
\end_layout

\begin_layout Plain Layout
      FUNCTION NEWESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout
        !computes the value of ((x-1)*h,(y-h)*h).
 Valid everywhere.
\end_layout

\begin_layout Plain Layout
        INTEGER X
\end_layout

\begin_layout Plain Layout
        INTEGER  Y
\end_layout

\begin_layout Plain Layout
        REAL H
\end_layout

\begin_layout Plain Layout
        INTEGER LENGTH
\end_layout

\begin_layout Plain Layout
        REAL NEWVALUE
\end_layout

\begin_layout Plain Layout
        REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout
        REAL NEWESTIMATE
\end_layout

\begin_layout Plain Layout
        REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout
        REAL F
\end_layout

\begin_layout Plain Layout
        IF (X==1 .AND.
 Y==1) THEN
\end_layout

\begin_layout Plain Layout
          NEWESTIMATE = 0.0
\end_layout

\begin_layout Plain Layout
        ELSE IF (X==1 .AND.
 Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout
          NEWESTIMATE = (1.0/2.0)*(PHIS(X+1,Y)+PHIS(X,Y-1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout
        ELSE IF (X==LENGTH .AND.
 Y==1) THEN
\end_layout

\begin_layout Plain Layout
          NEWESTIMATE = (1.0/2.0)*(PHIS(X-1,Y)+PHIS(X,Y+1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout
        ELSE IF (X==LENGTH .AND.
 Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout
          NEWESTIMATE = (1.0/2.0)*(PHIS(X-1,Y)+PHIS(X,Y-1)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout
        ELSE IF (X==1) THEN
\end_layout

\begin_layout Plain Layout
          NEWESTIMATE = (1.0/3.0)*(PHIS(X,Y+1)+PHIS(X,Y-1)+PHIS(X+1,Y)-H*H*F(X,Y,H
))
\end_layout

\begin_layout Plain Layout
        ELSE IF (X==LENGTH) THEN
\end_layout

\begin_layout Plain Layout
          NEWESTIMATE = (1.0/3.0)*(PHIS(X,Y+1)+PHIS(X,Y-1)+PHIS(X-1,Y)-H*H*F(X,Y,H
))
\end_layout

\begin_layout Plain Layout
        ELSE IF (Y==1) THEN
\end_layout

\begin_layout Plain Layout
          NEWESTIMATE = (1.0/3.0)*(PHIS(X+1,Y)+PHIS(X-1,Y)+PHIS(X,Y+1)-H*H*F(X,Y,H
))
\end_layout

\begin_layout Plain Layout
        ELSE IF (Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout
          NEWESTIMATE = (1.0/3.0)*(PHIS(X+1,Y)+PHIS(X-1,Y)+PHIS(X,Y-1)-H*H*F(X,Y,H
))
\end_layout

\begin_layout Plain Layout
        ELSE
\end_layout

\begin_layout Plain Layout
          NEWESTIMATE = SIMPLEESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout
        END IF
\end_layout

\begin_layout Plain Layout
        RETURN
\end_layout

\begin_layout Plain Layout
      END FUNCTION
\end_layout

\begin_layout Plain Layout
           
\end_layout

\begin_layout Plain Layout
      
\end_layout

\begin_layout Plain Layout
      FUNCTION SIMPLEESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout
        !computes a new estimate for the value of (x*h,y*h).
 Not valid on the boundary
\end_layout

\begin_layout Plain Layout
        INTEGER X,Y
\end_layout

\begin_layout Plain Layout
        REAL H
\end_layout

\begin_layout Plain Layout
        REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout
        INTEGER LENGTH
\end_layout

\begin_layout Plain Layout
        REAL F
\end_layout

\begin_layout Plain Layout
        REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout
        SIMPLEESTIMATE = (1.0/4.0)*(PHIS(X+1,Y)+PHIS(X,Y+1)+PHIS(X-1,Y)+PHIS(X,Y-1
)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout
        RETURN
\end_layout

\begin_layout Plain Layout
      END FUNCTION
\end_layout

\begin_layout Plain Layout
      
\end_layout

\begin_layout Plain Layout
      FUNCTION HIGHESTCHANGEFUN(OLD,NEW,PREVHIGHEST)
\end_layout

\begin_layout Plain Layout
        !returns the Highest change in (phi-)value given a new old value,
 new assignment and the previous highest change
\end_layout

\begin_layout Plain Layout
        REAL :: OLD
\end_layout

\begin_layout Plain Layout
        REAL :: NEW
\end_layout

\begin_layout Plain Layout
        REAL :: PREVHIGHEST
\end_layout

\begin_layout Plain Layout
        REAL :: CHANGE
\end_layout

\begin_layout Plain Layout
        REAL HIGHESTCHANGEFUN
\end_layout

\begin_layout Plain Layout
        CHANGE = ABS(OLD-NEW)
\end_layout

\begin_layout Plain Layout
        IF (CHANGE .GE.
 PREVHIGHEST) THEN
\end_layout

\begin_layout Plain Layout
          HIGHESTCHANGEFUN = CHANGE
\end_layout

\begin_layout Plain Layout
        ELSE
\end_layout

\begin_layout Plain Layout
          HIGHESTCHANGEFUN = PREVHIGHEST
\end_layout

\begin_layout Plain Layout
        END IF
\end_layout

\begin_layout Plain Layout
        RETURN
\end_layout

\begin_layout Plain Layout
      END FUNCTION
\end_layout

\begin_layout Plain Layout
      
\end_layout

\begin_layout Plain Layout
      FUNCTION LOWCHANGE(OLDLOWEST, LASTLOW)
\end_layout

\begin_layout Plain Layout
        !returns the lesser of two variables.
 Intended to compare change magnitudes to determine the lowest one.
\end_layout

\begin_layout Plain Layout
        REAL LOWCHANGE
\end_layout

\begin_layout Plain Layout
        REAL OLDLOWEST
\end_layout

\begin_layout Plain Layout
        REAL LASTLOW
\end_layout

\begin_layout Plain Layout
        IF (OLDLOWEST .LT.
 LASTLOW) THEN
\end_layout

\begin_layout Plain Layout
          LOWCHANGE = OLDLOWEST
\end_layout

\begin_layout Plain Layout
        ELSE
\end_layout

\begin_layout Plain Layout
          LOWCHANGE = LASTLOW
\end_layout

\begin_layout Plain Layout
        END IF
\end_layout

\begin_layout Plain Layout
      END FUNCTION
\end_layout

\begin_layout Plain Layout
      
\end_layout

\begin_layout Plain Layout
      FUNCTION ANALYTICALERROR(PHIS,LENGTH,H,SIZE)
\end_layout

\begin_layout Plain Layout
        !computes the analytically determined average squared error
\end_layout

\begin_layout Plain Layout
        INTEGER SIZE
\end_layout

\begin_layout Plain Layout
        INTEGER LENGTH
\end_layout

\begin_layout Plain Layout
        REAL H
\end_layout

\begin_layout Plain Layout
        REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout
        REAL ANALYTICAL
\end_layout

\begin_layout Plain Layout
        REAL AVGERROR
\end_layout

\begin_layout Plain Layout
        INTEGER I,J
\end_layout

\begin_layout Plain Layout
        REAL ANALYTICALERROR
\end_layout

\begin_layout Plain Layout
        AVGERROR = 0.0
\end_layout

\begin_layout Plain Layout
        DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout
          DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout
          AVGERROR = AVGERROR + ((PHIS(I,J)-ANALYTICAL(I,J,H))**2)/SIZE
\end_layout

\begin_layout Plain Layout
          END DO
\end_layout

\begin_layout Plain Layout
        END DO
\end_layout

\begin_layout Plain Layout
        ANALYTICALERROR = AVGERROR
\end_layout

\begin_layout Plain Layout
        RETURN
\end_layout

\begin_layout Plain Layout
      END FUNCTION
\end_layout

\begin_layout Plain Layout
      
\end_layout

\begin_layout Plain Layout
      PROGRAM SOLVER
\end_layout

\begin_layout Plain Layout
        REAL, PARAMETER :: H = 0.01
\end_layout

\begin_layout Plain Layout
        INTEGER, PARAMETER :: LENGTH = (1.0/H)
\end_layout

\begin_layout Plain Layout
        INTEGER, PARAMETER :: SIZE = LENGTH*LENGTH
\end_layout

\begin_layout Plain Layout
        REAL :: PHIS(LENGTH, LENGTH)
\end_layout

\begin_layout Plain Layout
        INTEGER, PARAMETER :: out_unit=20
\end_layout

\begin_layout Plain Layout
        REAL :: HIGHESTCHANGE
\end_layout

\begin_layout Plain Layout
        REAL :: NEWVALUE
\end_layout

\begin_layout Plain Layout
        REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout
        REAL NEWESTIMATE
\end_layout

\begin_layout Plain Layout
        REAL ANALYTICAL
\end_layout

\begin_layout Plain Layout
        INTEGER I,J
\end_layout

\begin_layout Plain Layout
        REAL HIGHESTCHANGEFUN
\end_layout

\begin_layout Plain Layout
        REAL LOWHIGHESTCHANGE
\end_layout

\begin_layout Plain Layout
        REAL AVGCHANGE
\end_layout

\begin_layout Plain Layout
        REAL LOWAVGCHANGE
\end_layout

\begin_layout Plain Layout
        REAL LOWCHANGE
\end_layout

\begin_layout Plain Layout
        REAL AVGERROR
\end_layout

\begin_layout Plain Layout
        REAL NUMAVGERROR
\end_layout

\begin_layout Plain Layout
        INTEGER NUMITERATIONS
\end_layout

\begin_layout Plain Layout
        REAL ANALYTICALERROR
\end_layout

\begin_layout Plain Layout
        REAL :: r(5,5)
\end_layout

\begin_layout Plain Layout
        INTEGER :: SEED
\end_layout

\begin_layout Plain Layout
        LOWAVGCHANGE = 20000.0
\end_layout

\begin_layout Plain Layout
        AVGCHANGE = 10000.0
\end_layout

\begin_layout Plain Layout
        LOWHIGHESTCHANGE = 20000.0
\end_layout

\begin_layout Plain Layout
        HIGHESTCHANGE = 10000.0
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        WRITE (*,*) "LENGTH IS ", LENGTH
\end_layout

\begin_layout Plain Layout
        !a friendly reminder that the real coordinate is (x-0.5)*h, not x*h
\end_layout

\begin_layout Plain Layout
        WRITE (*,*) "(LENGTH-0.5)*H IS ", ((LENGTH-0.5)*H)
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout
          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout
            PHIS(I,J) = RAND(SEED)*10.0 !SEED is intentionally uninitialized
 in the hope of providing some randomness.
 Sadly, no better solution was found.
\end_layout

\begin_layout Plain Layout
          END DO
\end_layout

\begin_layout Plain Layout
        END DO
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        NUMITERATIONS = 0
\end_layout

\begin_layout Plain Layout
        !the actual computation is performed here
\end_layout

\begin_layout Plain Layout
        DO WHILE  ((LOWHIGHESTCHANGE/HIGHESTCHANGE) > 1.0000126 .OR.
 (LOWAVGCHANGE/AVGCHANGE) > 1.0000365)
\end_layout

\begin_layout Plain Layout
          NUMITERATIONS = NUMITERATIONS + 1
\end_layout

\begin_layout Plain Layout
          LOWAVGCHANGE = LOWCHANGE(LOWAVGCHANGE, AVGCHANGE)
\end_layout

\begin_layout Plain Layout
          LOWHIGHESTCHANGE = LOWCHANGE(LOWHIGHESTCHANGE, HIGHESTCHANGE)
\end_layout

\begin_layout Plain Layout
          HIGHESTCHANGE = 0.0
\end_layout

\begin_layout Plain Layout
          AVGCHANGE = 0.0
\end_layout

\begin_layout Plain Layout
          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout
            DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout
                NEWVALUE = NEWESTIMATE(I,J,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout
                HIGHESTCHANGE = HIGHESTCHANGEFUN(PHIS(I,J),NEWVALUE,HIGHESTCHANG
E)
\end_layout

\begin_layout Plain Layout
                AVGCHANGE = AVGCHANGE + ((PHIS(I,J)-NEWVALUE)**2)/SIZE
\end_layout

\begin_layout Plain Layout
                PHIS(I,J) = NEWVALUE
\end_layout

\begin_layout Plain Layout
            END DO
\end_layout

\begin_layout Plain Layout
          END DO
\end_layout

\begin_layout Plain Layout
          !WRITE (*,*) "HIGHESTCHANGE IS ", HIGHESTCHANGE
\end_layout

\begin_layout Plain Layout
          !WRITE (*,*) "AVGCHANGE IS ", AVGCHANGE
\end_layout

\begin_layout Plain Layout
          !WRITE (*,*) "LOWAVGCHANGE IS ", LOWAVGCHANGE
\end_layout

\begin_layout Plain Layout
          !WRITE (*,*) "LOWHIGHESTCHANGE IS ", LOWHIGHESTCHANGE
\end_layout

\begin_layout Plain Layout
          !WRITE (*,*) ""
\end_layout

\begin_layout Plain Layout
        END DO
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        WRITE (*,*) "ratio", (LOWHIGHESTCHANGE/HIGHESTCHANGE) > 1.00000000
\end_layout

\begin_layout Plain Layout
        WRITE (*,*) "ratio", LOWHIGHESTCHANGE/HIGHESTCHANGE
\end_layout

\begin_layout Plain Layout
        WRITE (*,*) "ratio", (LOWAVGCHANGE/AVGCHANGE) > 1.00000000
\end_layout

\begin_layout Plain Layout
        WRITE (*,*) "ratio", LOWAVGCHANGE/AVGCHANGE
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        WRITE (*,*) "NUMITERATIONS IS ", NUMITERATIONS
\end_layout

\begin_layout Plain Layout
        !finds and prints the numerically determined error
\end_layout

\begin_layout Plain Layout
        NUMAVGERROR = 0.0
\end_layout

\begin_layout Plain Layout
        DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout
          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout
          NUMAVGERROR = NUMAVGERROR + ((PHIS(I,J)-NEWESTIMATE(I,J,H,PHIS,LENGTH)
)**2)/SIZE
\end_layout

\begin_layout Plain Layout
          END DO
\end_layout

\begin_layout Plain Layout
        END DO
\end_layout

\begin_layout Plain Layout
        WRITE (*,*) "AVERAGE SQUARE NUMERICALLY ESTIMATED ERROR IS ", NUMAVGERRO
R
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        !performance metrics.
 Analytically determined error is printed
\end_layout

\begin_layout Plain Layout
        AVGERROR = 0.0
\end_layout

\begin_layout Plain Layout
        DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout
          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout
          AVGERROR = AVGERROR + ((PHIS(I,J)-ANALYTICAL(I,J,H))**2)/SIZE
\end_layout

\begin_layout Plain Layout
          END DO
\end_layout

\begin_layout Plain Layout
        END DO
\end_layout

\begin_layout Plain Layout
        WRITE (*,*) "AVERAGE SQUARE ANALYTICALLY DETERMINED ERROR IS ",
 AVGERROR
\end_layout

\begin_layout Plain Layout
        
\end_layout

\begin_layout Plain Layout
        !writes results to file
\end_layout

\begin_layout Plain Layout
        open (unit=out_unit,file="results.txt",action="write",status="replace")
\end_layout

\begin_layout Plain Layout
        WRITE (OUT_UNIT,'(I4)') LENGTH
\end_layout

\begin_layout Plain Layout
        WRITE (OUT_UNIT,'(I4)') LENGTH
\end_layout

\begin_layout Plain Layout
        DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout
          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout
              WRITE (OUT_UNIT,'(F0.5)') PHIS(I,J)
\end_layout

\begin_layout Plain Layout
          END DO
\end_layout

\begin_layout Plain Layout
        END DO
\end_layout

\begin_layout Plain Layout
        close (out_unit)
\end_layout

\begin_layout Plain Layout
      END
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dirichlet(dirichlet.f95):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

!gfortran dirichlet.f95 -fimplicit-none -O3 -o dirichlet -fdefault-real-8
 && time ./dirichlet
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      FUNCTION F(X,Y,H)
\end_layout

\begin_layout Plain Layout

        !the right side of the poisson equation
\end_layout

\begin_layout Plain Layout

        INTEGER X,Y
\end_layout

\begin_layout Plain Layout

        REAL H
\end_layout

\begin_layout Plain Layout

        REAL F
\end_layout

\begin_layout Plain Layout

        F=1
\end_layout

\begin_layout Plain Layout

        RETURN
\end_layout

\begin_layout Plain Layout

      END FUNCTION
\end_layout

\begin_layout Plain Layout

           
\end_layout

\begin_layout Plain Layout

      FUNCTION ANALYTICAL(X,Y,H)
\end_layout

\begin_layout Plain Layout

        !computes the analytical solution
\end_layout

\begin_layout Plain Layout

        REAL ANALYTICAL
\end_layout

\begin_layout Plain Layout

        INTEGER :: X
\end_layout

\begin_layout Plain Layout

        INTEGER :: Y
\end_layout

\begin_layout Plain Layout

        REAL :: H
\end_layout

\begin_layout Plain Layout

        REAL :: XC
\end_layout

\begin_layout Plain Layout

        REAL :: YC
\end_layout

\begin_layout Plain Layout

        XC = (X-1)*H
\end_layout

\begin_layout Plain Layout

        YC = (Y-1)*H
\end_layout

\begin_layout Plain Layout

        ANALYTICAL = 0.25*(XC**2+YC**2)
\end_layout

\begin_layout Plain Layout

        RETURN
\end_layout

\begin_layout Plain Layout

      END FUNCTION
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      FUNCTION NEWESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

        !computes the value of ((x-1)*h,(y-h)*h).
 Valid everywhere.
\end_layout

\begin_layout Plain Layout

        INTEGER X
\end_layout

\begin_layout Plain Layout

        INTEGER  Y
\end_layout

\begin_layout Plain Layout

        REAL H
\end_layout

\begin_layout Plain Layout

        INTEGER LENGTH
\end_layout

\begin_layout Plain Layout

        REAL NEWVALUE
\end_layout

\begin_layout Plain Layout

        REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout

        REAL NEWESTIMATE
\end_layout

\begin_layout Plain Layout

        REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout

        REAL F
\end_layout

\begin_layout Plain Layout

        REAL :: ORIGINDEMAND
\end_layout

\begin_layout Plain Layout

        REAL :: XC
\end_layout

\begin_layout Plain Layout

        REAL :: YC
\end_layout

\begin_layout Plain Layout

        XC = (X-1)*H
\end_layout

\begin_layout Plain Layout

        YC = (Y-1)*H
\end_layout

\begin_layout Plain Layout

        IF (X==1 .OR.
 Y==1 .OR.
 X==LENGTH .OR.
 Y==LENGTH) THEN
\end_layout

\begin_layout Plain Layout

          NEWESTIMATE = 0.25*(XC**2+YC**2)
\end_layout

\begin_layout Plain Layout

        ELSE
\end_layout

\begin_layout Plain Layout

          NEWESTIMATE = SIMPLEESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

        END IF
\end_layout

\begin_layout Plain Layout

        RETURN
\end_layout

\begin_layout Plain Layout

      END FUNCTION
\end_layout

\begin_layout Plain Layout

           
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      FUNCTION SIMPLEESTIMATE(X,Y,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

        !computes a new estimate for the value of (x*h,y*h).
 Not valid on the boundary
\end_layout

\begin_layout Plain Layout

        INTEGER X,Y
\end_layout

\begin_layout Plain Layout

        REAL H
\end_layout

\begin_layout Plain Layout

        REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout

        INTEGER LENGTH
\end_layout

\begin_layout Plain Layout

        REAL F
\end_layout

\begin_layout Plain Layout

        REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout

        SIMPLEESTIMATE = (1.0/4.0)*(PHIS(X+1,Y)+PHIS(X,Y+1)+PHIS(X-1,Y)+PHIS(X,Y-1
)-H*H*F(X,Y,H))
\end_layout

\begin_layout Plain Layout

        RETURN
\end_layout

\begin_layout Plain Layout

      END FUNCTION
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      FUNCTION HIGHESTCHANGEFUN(OLD,NEW,PREVHIGHEST)
\end_layout

\begin_layout Plain Layout

        !returns the gighest change in (phi-)value given a new old value,
 new assignment and the previous highest change
\end_layout

\begin_layout Plain Layout

        REAL :: OLD
\end_layout

\begin_layout Plain Layout

        REAL :: NEW
\end_layout

\begin_layout Plain Layout

        REAL :: PREVHIGHEST
\end_layout

\begin_layout Plain Layout

        REAL :: CHANGE
\end_layout

\begin_layout Plain Layout

        REAL HIGHESTCHANGEFUN
\end_layout

\begin_layout Plain Layout

        CHANGE = ABS(OLD-NEW)
\end_layout

\begin_layout Plain Layout

        IF (CHANGE .GE.
 PREVHIGHEST) THEN
\end_layout

\begin_layout Plain Layout

          HIGHESTCHANGEFUN = CHANGE
\end_layout

\begin_layout Plain Layout

        ELSE
\end_layout

\begin_layout Plain Layout

          HIGHESTCHANGEFUN = PREVHIGHEST
\end_layout

\begin_layout Plain Layout

        END IF
\end_layout

\begin_layout Plain Layout

        RETURN
\end_layout

\begin_layout Plain Layout

      END FUNCTION
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      FUNCTION LOWCHANGE(OLDLOWEST, LASTLOW)
\end_layout

\begin_layout Plain Layout

        !returns the lesser of two variables.
 Intended to compare change magnitudes to determine the lowest one.
\end_layout

\begin_layout Plain Layout

        REAL LOWCHANGE
\end_layout

\begin_layout Plain Layout

        REAL OLDLOWEST
\end_layout

\begin_layout Plain Layout

        REAL LASTLOW
\end_layout

\begin_layout Plain Layout

        IF (OLDLOWEST .LT.
 LASTLOW) THEN
\end_layout

\begin_layout Plain Layout

          LOWCHANGE = OLDLOWEST
\end_layout

\begin_layout Plain Layout

        ELSE
\end_layout

\begin_layout Plain Layout

          LOWCHANGE = LASTLOW
\end_layout

\begin_layout Plain Layout

        END IF
\end_layout

\begin_layout Plain Layout

      END FUNCTION
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      FUNCTION ANALYTICALERROR(PHIS,LENGTH,H,SIZE)
\end_layout

\begin_layout Plain Layout

        !computes the analytically determined average squared error
\end_layout

\begin_layout Plain Layout

        INTEGER SIZE
\end_layout

\begin_layout Plain Layout

        INTEGER LENGTH
\end_layout

\begin_layout Plain Layout

        REAL H
\end_layout

\begin_layout Plain Layout

        REAL :: PHIS(LENGTH,LENGTH)
\end_layout

\begin_layout Plain Layout

        REAL ANALYTICAL
\end_layout

\begin_layout Plain Layout

        REAL AVGERROR
\end_layout

\begin_layout Plain Layout

        INTEGER I,J
\end_layout

\begin_layout Plain Layout

        REAL ANALYTICALERROR
\end_layout

\begin_layout Plain Layout

        AVGERROR = 0.0
\end_layout

\begin_layout Plain Layout

        DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout

          DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout

          AVGERROR = AVGERROR + ((PHIS(I,J)-ANALYTICAL(I,J,H))**2)/SIZE
\end_layout

\begin_layout Plain Layout

          END DO
\end_layout

\begin_layout Plain Layout

        END DO
\end_layout

\begin_layout Plain Layout

        ANALYTICALERROR = AVGERROR
\end_layout

\begin_layout Plain Layout

        RETURN
\end_layout

\begin_layout Plain Layout

      END FUNCTION
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      PROGRAM SOLVER
\end_layout

\begin_layout Plain Layout

        REAL, PARAMETER :: H = 0.01
\end_layout

\begin_layout Plain Layout

        INTEGER, PARAMETER :: LENGTH = (1.0/H)+1
\end_layout

\begin_layout Plain Layout

        INTEGER, PARAMETER :: SIZE = LENGTH*LENGTH
\end_layout

\begin_layout Plain Layout

        REAL :: PHIS(LENGTH, LENGTH)
\end_layout

\begin_layout Plain Layout

        INTEGER, PARAMETER :: out_unit=20
\end_layout

\begin_layout Plain Layout

        REAL :: HIGHESTCHANGE
\end_layout

\begin_layout Plain Layout

        REAL :: NEWVALUE
\end_layout

\begin_layout Plain Layout

        REAL SIMPLEESTIMATE
\end_layout

\begin_layout Plain Layout

        REAL NEWESTIMATE
\end_layout

\begin_layout Plain Layout

        REAL ANALYTICAL
\end_layout

\begin_layout Plain Layout

        INTEGER I,J
\end_layout

\begin_layout Plain Layout

        REAL HIGHESTCHANGEFUN
\end_layout

\begin_layout Plain Layout

        REAL LOWHIGHESTCHANGE
\end_layout

\begin_layout Plain Layout

        REAL AVGCHANGE
\end_layout

\begin_layout Plain Layout

        REAL LOWAVGCHANGE
\end_layout

\begin_layout Plain Layout

        REAL LOWCHANGE
\end_layout

\begin_layout Plain Layout

        REAL AVGERROR
\end_layout

\begin_layout Plain Layout

        REAL NUMAVGERROR
\end_layout

\begin_layout Plain Layout

        INTEGER NUMITERATIONS
\end_layout

\begin_layout Plain Layout

        REAL ANALYTICALERROR
\end_layout

\begin_layout Plain Layout

        LOWAVGCHANGE = 20.0
\end_layout

\begin_layout Plain Layout

        AVGCHANGE = 1.0
\end_layout

\begin_layout Plain Layout

        LOWHIGHESTCHANGE = 20.0
\end_layout

\begin_layout Plain Layout

        HIGHESTCHANGE = 10.0
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        !a friendly reminder that what the real coordinate is (x-1)*h, not
 x*h
\end_layout

\begin_layout Plain Layout

        WRITE (*,*) "(LENGTH-1)*H IS ", ((LENGTH-1)*H)
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout

          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout

            PHIS(I,J) = RAND(0)*10
\end_layout

\begin_layout Plain Layout

          END DO
\end_layout

\begin_layout Plain Layout

        END DO
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        NUMITERATIONS = 0
\end_layout

\begin_layout Plain Layout

        !the actual computation is performed here
\end_layout

\begin_layout Plain Layout

        DO WHILE  ((LOWHIGHESTCHANGE/HIGHESTCHANGE) > 1.00001 .OR.
 (LOWAVGCHANGE/AVGCHANGE) > 1.00001)
\end_layout

\begin_layout Plain Layout

          NUMITERATIONS = NUMITERATIONS + 1
\end_layout

\begin_layout Plain Layout

          LOWAVGCHANGE = LOWCHANGE(LOWAVGCHANGE, AVGCHANGE)
\end_layout

\begin_layout Plain Layout

          LOWHIGHESTCHANGE = LOWCHANGE(LOWHIGHESTCHANGE, HIGHESTCHANGE)
\end_layout

\begin_layout Plain Layout

          HIGHESTCHANGE = 0.0
\end_layout

\begin_layout Plain Layout

          AVGCHANGE = 0.0
\end_layout

\begin_layout Plain Layout

          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout

            DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout

                NEWVALUE = NEWESTIMATE(I,J,H,PHIS,LENGTH)
\end_layout

\begin_layout Plain Layout

                HIGHESTCHANGE = HIGHESTCHANGEFUN(PHIS(I,J),NEWVALUE,HIGHESTCHANG
E)
\end_layout

\begin_layout Plain Layout

                AVGCHANGE = AVGCHANGE + ((PHIS(I,J)-NEWVALUE)**2)/SIZE
\end_layout

\begin_layout Plain Layout

                PHIS(I,J) = NEWVALUE
\end_layout

\begin_layout Plain Layout

            END DO
\end_layout

\begin_layout Plain Layout

          END DO
\end_layout

\begin_layout Plain Layout

        END DO
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        WRITE (*,*) "NUMITERATIONS IS ", NUMITERATIONS
\end_layout

\begin_layout Plain Layout

        !finds and prints the numerically determined error
\end_layout

\begin_layout Plain Layout

        NUMAVGERROR = 0.0
\end_layout

\begin_layout Plain Layout

        DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout

          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout

          NUMAVGERROR = NUMAVGERROR + ((PHIS(I,J)-NEWESTIMATE(I,J,H,PHIS,LENGTH)
)**2)/SIZE
\end_layout

\begin_layout Plain Layout

          END DO
\end_layout

\begin_layout Plain Layout

        END DO
\end_layout

\begin_layout Plain Layout

        WRITE (*,*) "AVERAGE SQUARE NUMERICALLY ESTIMATED ERROR IS ", NUMAVGERRO
R
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        !performance metrics.
 Analytically determined error is printed
\end_layout

\begin_layout Plain Layout

        AVGERROR = 0.0
\end_layout

\begin_layout Plain Layout

        DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout

          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout

          AVGERROR = AVGERROR + ((PHIS(I,J)-ANALYTICAL(I,J,H))**2)/SIZE
\end_layout

\begin_layout Plain Layout

          END DO
\end_layout

\begin_layout Plain Layout

        END DO
\end_layout

\begin_layout Plain Layout

        WRITE (*,*) "AVERAGE SQUARE ANALYTICALLY DETERMINED ERROR IS ",
 AVGERROR
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        !writes results to file
\end_layout

\begin_layout Plain Layout

        open (unit=out_unit,file="results.txt",action="write",status="replace")
\end_layout

\begin_layout Plain Layout

        WRITE (OUT_UNIT,'(I4)') LENGTH
\end_layout

\begin_layout Plain Layout

        WRITE (OUT_UNIT,'(I4)') LENGTH
\end_layout

\begin_layout Plain Layout

        DO I=1,LENGTH
\end_layout

\begin_layout Plain Layout

          DO J=1,LENGTH
\end_layout

\begin_layout Plain Layout

              WRITE (OUT_UNIT,'(F0.5)') PHIS(I,J)
\end_layout

\begin_layout Plain Layout

          END DO
\end_layout

\begin_layout Plain Layout

        END DO
\end_layout

\begin_layout Plain Layout

        close (out_unit)
\end_layout

\begin_layout Plain Layout

      END
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Display(array.c):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//clang -o array array.c shaderutil.c -lGL -lglut -lm -lGLEW -O3 && ./array
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Test variable array indexing in a vertex shader.
\end_layout

\begin_layout Plain Layout

 * Brian Paul
\end_layout

\begin_layout Plain Layout

 * 17 April 2009
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <assert.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <math.h>
\end_layout

\begin_layout Plain Layout

#include <GL/glew.h>
\end_layout

\begin_layout Plain Layout

#include "glut_wrap.h"
\end_layout

\begin_layout Plain Layout

#include "shaderutil.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int LENGTH;
\end_layout

\begin_layout Plain Layout

float *inm;
\end_layout

\begin_layout Plain Layout

#define GLmaxdiff 2.0
\end_layout

\begin_layout Plain Layout

float highest = 0.0;
\end_layout

\begin_layout Plain Layout

float lowest = 0.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * The vertex position.z is used as a (variable) index into an
\end_layout

\begin_layout Plain Layout

 * array which returns a new Z value.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

static const char *VertShaderText =
\end_layout

\begin_layout Plain Layout

   "uniform sampler2D tex1; 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "uniform float HeightArray[20]; 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "void main() 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "{ 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "   vec4 pos = gl_Vertex; 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "   int i = int(pos.z * 9.5); 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "   pos.z = HeightArray[i]; 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "   gl_Position = gl_ModelViewProjectionMatrix * pos; 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "   gl_FrontColor = pos; 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "} 
\backslash
n";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static const char *FragShaderText =
\end_layout

\begin_layout Plain Layout

   "void main() 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "{ 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "   gl_FragColor = gl_Color; 
\backslash
n"
\end_layout

\begin_layout Plain Layout

   "} 
\backslash
n";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static GLuint fragShader;
\end_layout

\begin_layout Plain Layout

static GLuint vertShader;
\end_layout

\begin_layout Plain Layout

static GLuint program;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static GLint win = 0;
\end_layout

\begin_layout Plain Layout

static GLboolean Anim = GL_TRUE;
\end_layout

\begin_layout Plain Layout

static GLboolean WireFrame = GL_TRUE;
\end_layout

\begin_layout Plain Layout

static GLfloat xRot = -70.0f, yRot = 0.0f, zRot = 0.0f;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void
\end_layout

\begin_layout Plain Layout

Idle(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   zRot = 90 + glutGet(GLUT_ELAPSED_TIME) * 0.05;
\end_layout

\begin_layout Plain Layout

   glutPostRedisplay();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/** z=f(x,y) */
\end_layout

\begin_layout Plain Layout

static float
\end_layout

\begin_layout Plain Layout

fz(float x, float y)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   return fabs(cos(1.5*x) + cos(1.5*y));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static float
\end_layout

\begin_layout Plain Layout

getinm(float x, float y, float minx, float maxx, float miny, float maxy)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int i = ((x+(-minx))/(maxx-minx))*LENGTH;
\end_layout

\begin_layout Plain Layout

  int j = ((y+(-miny))/(maxy-miny))*LENGTH;
\end_layout

\begin_layout Plain Layout

  int index = i*LENGTH+j;
\end_layout

\begin_layout Plain Layout

  if(index<0){index=0;}
\end_layout

\begin_layout Plain Layout

  if(index>LENGTH*LENGTH){index=LENGTH*LENGTH-1;}
\end_layout

\begin_layout Plain Layout

  //printf("x is %f, y is %f, i is %d, j is %d, index is %d
\backslash
n",x,y,i,j,index);            //disabled for better performance
\end_layout

\begin_layout Plain Layout

  return inm[index];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void
\end_layout

\begin_layout Plain Layout

DrawMesh(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLfloat xmin = -2.0, xmax = 2.0;
\end_layout

\begin_layout Plain Layout

   GLfloat ymin = -2.0, ymax = 2.0;
\end_layout

\begin_layout Plain Layout

   GLuint xdivs = 60, ydivs = 60;
\end_layout

\begin_layout Plain Layout

   GLfloat dx = (xmax - xmin) / xdivs;
\end_layout

\begin_layout Plain Layout

   GLfloat dy = (ymax - ymin) / ydivs;
\end_layout

\begin_layout Plain Layout

   GLfloat ds = 1.0 / xdivs, dt = 1.0 / ydivs;
\end_layout

\begin_layout Plain Layout

   GLfloat x, y, s, t;
\end_layout

\begin_layout Plain Layout

   GLuint i, j;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   float scale = GLmaxdiff/(highest-lowest);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   y = ymin;
\end_layout

\begin_layout Plain Layout

   t = 0.0;
\end_layout

\begin_layout Plain Layout

   for (i = 0; i < ydivs; i++) {
\end_layout

\begin_layout Plain Layout

      x = xmin;
\end_layout

\begin_layout Plain Layout

      s = 0.0;
\end_layout

\begin_layout Plain Layout

      glBegin(GL_QUAD_STRIP);
\end_layout

\begin_layout Plain Layout

      for (j = 0; j < xdivs; j++) {
\end_layout

\begin_layout Plain Layout

         float z0 = scale*getinm(x, y, xmin,xmax,ymin,ymax), z1 = scale*getinm(x
, y + dy, xmin,xmax,ymin,ymax);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         glTexCoord2f(s, t);
\end_layout

\begin_layout Plain Layout

         glVertex3f(x, y, z0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         glTexCoord2f(s, t + dt);
\end_layout

\begin_layout Plain Layout

         glVertex3f(x, y + dy, z1);
\end_layout

\begin_layout Plain Layout

         x += dx;
\end_layout

\begin_layout Plain Layout

         s += ds;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      glEnd();
\end_layout

\begin_layout Plain Layout

      y += dy;
\end_layout

\begin_layout Plain Layout

      t += dt;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   /*y = ymin;
\end_layout

\begin_layout Plain Layout

   t = 0.0;
\end_layout

\begin_layout Plain Layout

   for (i = 0; i < ydivs; i++) {
\end_layout

\begin_layout Plain Layout

      x = xmin;
\end_layout

\begin_layout Plain Layout

      s = 0.0;
\end_layout

\begin_layout Plain Layout

      glBegin(GL_QUAD_STRIP);
\end_layout

\begin_layout Plain Layout

      for (j = 0; j < xdivs; j++) {
\end_layout

\begin_layout Plain Layout

         float z0 = fz(x, y), z1 = fz(x, y + dy);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         glTexCoord2f(s, t);
\end_layout

\begin_layout Plain Layout

         glVertex3f(x, y, z0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         glTexCoord2f(s, t + dt);
\end_layout

\begin_layout Plain Layout

         glVertex3f(x, y + dy, z1);
\end_layout

\begin_layout Plain Layout

         x += dx;
\end_layout

\begin_layout Plain Layout

         s += ds;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      glEnd();
\end_layout

\begin_layout Plain Layout

      y += dy;
\end_layout

\begin_layout Plain Layout

      t += dt;
\end_layout

\begin_layout Plain Layout

   }*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void
\end_layout

\begin_layout Plain Layout

Redisplay(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   if (WireFrame)
\end_layout

\begin_layout Plain Layout

      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
\end_layout

\begin_layout Plain Layout

   else
\end_layout

\begin_layout Plain Layout

      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   glPushMatrix();
\end_layout

\begin_layout Plain Layout

   glRotatef(xRot, 1.0f, 0.0f, 0.0f);
\end_layout

\begin_layout Plain Layout

   glRotatef(yRot, 0.0f, 1.0f, 0.0f);
\end_layout

\begin_layout Plain Layout

   glRotatef(zRot, 0.0f, 0.0f, 1.0f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   glPushMatrix();
\end_layout

\begin_layout Plain Layout

   DrawMesh();
\end_layout

\begin_layout Plain Layout

   glPopMatrix();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   glPopMatrix();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   glutSwapBuffers();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void
\end_layout

\begin_layout Plain Layout

Reshape(int width, int height)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   glViewport(0, 0, width, height);
\end_layout

\begin_layout Plain Layout

   glMatrixMode(GL_PROJECTION);
\end_layout

\begin_layout Plain Layout

   glLoadIdentity();
\end_layout

\begin_layout Plain Layout

   glFrustum(-1.0, 1.0, -1.0, 1.0, 5.0, 25.0);
\end_layout

\begin_layout Plain Layout

   glMatrixMode(GL_MODELVIEW);
\end_layout

\begin_layout Plain Layout

   glLoadIdentity();
\end_layout

\begin_layout Plain Layout

   glTranslatef(0.0f, 0.0f, -15.0f);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void
\end_layout

\begin_layout Plain Layout

CleanUp(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   glDeleteShader(fragShader);
\end_layout

\begin_layout Plain Layout

   glDeleteShader(vertShader);
\end_layout

\begin_layout Plain Layout

   glDeleteProgram(program);
\end_layout

\begin_layout Plain Layout

   glutDestroyWindow(win);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void
\end_layout

\begin_layout Plain Layout

Key(unsigned char key, int x, int y)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   const GLfloat step = 2.0;
\end_layout

\begin_layout Plain Layout

   (void) x;
\end_layout

\begin_layout Plain Layout

   (void) y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   switch(key) {
\end_layout

\begin_layout Plain Layout

   case 'a':
\end_layout

\begin_layout Plain Layout

      Anim = !Anim;
\end_layout

\begin_layout Plain Layout

      if (Anim)
\end_layout

\begin_layout Plain Layout

         glutIdleFunc(Idle);
\end_layout

\begin_layout Plain Layout

      else
\end_layout

\begin_layout Plain Layout

         glutIdleFunc(NULL);
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

   case 'w':
\end_layout

\begin_layout Plain Layout

      WireFrame = !WireFrame;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

   case 'z':
\end_layout

\begin_layout Plain Layout

      zRot += step;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

   case 'Z':
\end_layout

\begin_layout Plain Layout

      zRot -= step;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

   case 27:
\end_layout

\begin_layout Plain Layout

      CleanUp();
\end_layout

\begin_layout Plain Layout

      exit(0);
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   glutPostRedisplay();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void
\end_layout

\begin_layout Plain Layout

SpecialKey(int key, int x, int y)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   const GLfloat step = 2.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   (void) x;
\end_layout

\begin_layout Plain Layout

   (void) y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   switch(key) {
\end_layout

\begin_layout Plain Layout

   case GLUT_KEY_UP:
\end_layout

\begin_layout Plain Layout

      xRot += step;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

   case GLUT_KEY_DOWN:
\end_layout

\begin_layout Plain Layout

      xRot -= step;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

   case GLUT_KEY_LEFT:
\end_layout

\begin_layout Plain Layout

      yRot -= step;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

   case GLUT_KEY_RIGHT:
\end_layout

\begin_layout Plain Layout

      yRot += step;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   glutPostRedisplay();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void
\end_layout

\begin_layout Plain Layout

Init(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLfloat HeightArray[20];
\end_layout

\begin_layout Plain Layout

   GLint u, i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   if (!ShadersSupported())
\end_layout

\begin_layout Plain Layout

      exit(1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   vertShader = CompileShaderText(GL_VERTEX_SHADER, VertShaderText);
\end_layout

\begin_layout Plain Layout

   fragShader = CompileShaderText(GL_FRAGMENT_SHADER, FragShaderText);
\end_layout

\begin_layout Plain Layout

   program = LinkShaders(vertShader, fragShader);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   glUseProgram(program);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   /* Setup the HeightArray[] uniform */
\end_layout

\begin_layout Plain Layout

   for (i = 0; i < 20; i++)
\end_layout

\begin_layout Plain Layout

      HeightArray[i] = i / 20.0;
\end_layout

\begin_layout Plain Layout

   u = glGetUniformLocation(program, "HeightArray");
\end_layout

\begin_layout Plain Layout

   glUniform1fv(u, 20, HeightArray);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   assert(glGetError() == 0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   glClearColor(0.4f, 0.4f, 0.8f, 0.0f);
\end_layout

\begin_layout Plain Layout

   glEnable(GL_DEPTH_TEST);
\end_layout

\begin_layout Plain Layout

   glColor3f(1, 1, 1);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int
\end_layout

\begin_layout Plain Layout

main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  srand(time(NULL));
\end_layout

\begin_layout Plain Layout

  float in = 0.0;
\end_layout

\begin_layout Plain Layout

  int control = 0;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  FILE *f = fopen("results.txt", "r");
\end_layout

\begin_layout Plain Layout

  fscanf(f,"%d",&LENGTH);
\end_layout

\begin_layout Plain Layout

  fscanf(f,"%d",&control);
\end_layout

\begin_layout Plain Layout

  assert(LENGTH==control);
\end_layout

\begin_layout Plain Layout

  float arr[LENGTH*LENGTH];
\end_layout

\begin_layout Plain Layout

  inm = &arr;
\end_layout

\begin_layout Plain Layout

  for(int i=0; i<LENGTH*LENGTH; i++)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    fscanf(f,"%f",&in);
\end_layout

\begin_layout Plain Layout

    inm[i] = in;
\end_layout

\begin_layout Plain Layout

    //inm[i] = rand()%GLmaxdiff;
\end_layout

\begin_layout Plain Layout

    if (in < lowest)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      lowest = in;
\end_layout

\begin_layout Plain Layout

    } 
\end_layout

\begin_layout Plain Layout

    else if (in > highest)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      highest = in;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    //printf("%f
\backslash
n", in);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  fclose(f);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

    * Start OpenGL stuff
\end_layout

\begin_layout Plain Layout

    */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   glutInit(&argc, argv);
\end_layout

\begin_layout Plain Layout

   glutInitWindowSize(500, 500);
\end_layout

\begin_layout Plain Layout

   glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
\end_layout

\begin_layout Plain Layout

   win = glutCreateWindow(argv[0]);
\end_layout

\begin_layout Plain Layout

   glewInit();
\end_layout

\begin_layout Plain Layout

   glutReshapeFunc(Reshape);
\end_layout

\begin_layout Plain Layout

   glutKeyboardFunc(Key);
\end_layout

\begin_layout Plain Layout

   glutSpecialFunc(SpecialKey);
\end_layout

\begin_layout Plain Layout

   glutDisplayFunc(Redisplay);
\end_layout

\begin_layout Plain Layout

   Init();
\end_layout

\begin_layout Plain Layout

   if (Anim)
\end_layout

\begin_layout Plain Layout

      glutIdleFunc(Idle);
\end_layout

\begin_layout Plain Layout

   glutMainLoop();
\end_layout

\begin_layout Plain Layout

   return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Display support(glut_wrap.h)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#ifndef GLUT_WRAP_H
\end_layout

\begin_layout Plain Layout

#define GLUT_WRAP_H
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#ifdef HAVE_FREEGLUT
\end_layout

\begin_layout Plain Layout

#  include <GL/freeglut.h>
\end_layout

\begin_layout Plain Layout

#elif defined __APPLE__
\end_layout

\begin_layout Plain Layout

#  include <GLUT/glut.h>
\end_layout

\begin_layout Plain Layout

#else
\end_layout

\begin_layout Plain Layout

#  include <GL/glut.h>
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#ifndef GLAPIENTRY
\end_layout

\begin_layout Plain Layout

#define GLAPIENTRY
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif /* ! GLUT_WRAP_H */
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Display support(shaderutil.c)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Utilities for OpenGL shading language
\end_layout

\begin_layout Plain Layout

 *
\end_layout

\begin_layout Plain Layout

 * Brian Paul
\end_layout

\begin_layout Plain Layout

 * 9 April 2008
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <assert.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <GL/glew.h>
\end_layout

\begin_layout Plain Layout

#include "glut_wrap.h"
\end_layout

\begin_layout Plain Layout

#include "shaderutil.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/** time to compile previous shader */
\end_layout

\begin_layout Plain Layout

static GLdouble CompileTime = 0.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/** time to linke previous program */
\end_layout

\begin_layout Plain Layout

static GLdouble LinkTime = 0.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PFNGLCREATESHADERPROC CreateShader = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLDELETESHADERPROC DeleteShader = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLSHADERSOURCEPROC ShaderSource = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLGETSHADERIVPROC GetShaderiv = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLGETSHADERINFOLOGPROC GetShaderInfoLog = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLCREATEPROGRAMPROC CreateProgram = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLDELETEPROGRAMPROC DeleteProgram = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLATTACHSHADERPROC AttachShader = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLLINKPROGRAMPROC LinkProgram = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLUSEPROGRAMPROC UseProgram = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLGETPROGRAMIVPROC GetProgramiv = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLGETPROGRAMINFOLOGPROC GetProgramInfoLog = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLVALIDATEPROGRAMARBPROC ValidateProgramARB = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLUNIFORM1IPROC Uniform1i = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLUNIFORM1FVPROC Uniform1fv = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLUNIFORM2FVPROC Uniform2fv = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLUNIFORM3FVPROC Uniform3fv = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLUNIFORM4FVPROC Uniform4fv = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLUNIFORMMATRIX4FVPROC UniformMatrix4fv = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLGETACTIVEATTRIBPROC GetActiveAttrib = NULL;
\end_layout

\begin_layout Plain Layout

PFNGLGETATTRIBLOCATIONPROC GetAttribLocation = NULL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void GLAPIENTRY
\end_layout

\begin_layout Plain Layout

fake_ValidateProgram(GLuint prog)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   (void) prog;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

GLboolean
\end_layout

\begin_layout Plain Layout

ShadersSupported(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   if (GLEW_VERSION_2_0) {
\end_layout

\begin_layout Plain Layout

      CreateShader = glCreateShader;
\end_layout

\begin_layout Plain Layout

      DeleteShader = glDeleteShader;
\end_layout

\begin_layout Plain Layout

      ShaderSource = glShaderSource;
\end_layout

\begin_layout Plain Layout

      GetShaderiv = glGetShaderiv;
\end_layout

\begin_layout Plain Layout

      GetShaderInfoLog = glGetShaderInfoLog;
\end_layout

\begin_layout Plain Layout

      CreateProgram = glCreateProgram;
\end_layout

\begin_layout Plain Layout

      DeleteProgram = glDeleteProgram;
\end_layout

\begin_layout Plain Layout

      AttachShader = glAttachShader;
\end_layout

\begin_layout Plain Layout

      LinkProgram = glLinkProgram;
\end_layout

\begin_layout Plain Layout

      UseProgram = glUseProgram;
\end_layout

\begin_layout Plain Layout

      GetProgramiv = glGetProgramiv;
\end_layout

\begin_layout Plain Layout

      GetProgramInfoLog = glGetProgramInfoLog;
\end_layout

\begin_layout Plain Layout

      ValidateProgramARB = (GLEW_ARB_shader_objects)
\end_layout

\begin_layout Plain Layout

	 ? glValidateProgramARB : fake_ValidateProgram;
\end_layout

\begin_layout Plain Layout

      Uniform1i = glUniform1i;
\end_layout

\begin_layout Plain Layout

      Uniform1fv = glUniform1fv;
\end_layout

\begin_layout Plain Layout

      Uniform2fv = glUniform2fv;
\end_layout

\begin_layout Plain Layout

      Uniform3fv = glUniform3fv;
\end_layout

\begin_layout Plain Layout

      Uniform4fv = glUniform4fv;
\end_layout

\begin_layout Plain Layout

      UniformMatrix4fv = glUniformMatrix4fv;
\end_layout

\begin_layout Plain Layout

      GetActiveAttrib = glGetActiveAttrib;
\end_layout

\begin_layout Plain Layout

      GetAttribLocation = glGetAttribLocation;
\end_layout

\begin_layout Plain Layout

      return GL_TRUE;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   else if (GLEW_ARB_vertex_shader && GLEW_ARB_fragment_shader
\end_layout

\begin_layout Plain Layout

	    && GLEW_ARB_shader_objects) {
\end_layout

\begin_layout Plain Layout

      fprintf(stderr, "Warning: Trying ARB GLSL instead of OpenGL 2.x.
  This may not work.
\backslash
n");
\end_layout

\begin_layout Plain Layout

      CreateShader = glCreateShaderObjectARB;
\end_layout

\begin_layout Plain Layout

      DeleteShader = glDeleteObjectARB;
\end_layout

\begin_layout Plain Layout

      ShaderSource = glShaderSourceARB;
\end_layout

\begin_layout Plain Layout

      GetShaderiv = glGetObjectParameterivARB;
\end_layout

\begin_layout Plain Layout

      GetShaderInfoLog = glGetInfoLogARB;
\end_layout

\begin_layout Plain Layout

      CreateProgram = glCreateProgramObjectARB;
\end_layout

\begin_layout Plain Layout

      DeleteProgram = glDeleteObjectARB;
\end_layout

\begin_layout Plain Layout

      AttachShader = glAttachObjectARB;
\end_layout

\begin_layout Plain Layout

      LinkProgram = glLinkProgramARB;
\end_layout

\begin_layout Plain Layout

      UseProgram = glUseProgramObjectARB;
\end_layout

\begin_layout Plain Layout

      GetProgramiv = glGetObjectParameterivARB;
\end_layout

\begin_layout Plain Layout

      GetProgramInfoLog = glGetInfoLogARB;
\end_layout

\begin_layout Plain Layout

      ValidateProgramARB = glValidateProgramARB;
\end_layout

\begin_layout Plain Layout

      Uniform1i = glUniform1iARB;
\end_layout

\begin_layout Plain Layout

      Uniform1fv = glUniform1fvARB;
\end_layout

\begin_layout Plain Layout

      Uniform2fv = glUniform2fvARB;
\end_layout

\begin_layout Plain Layout

      Uniform3fv = glUniform3fvARB;
\end_layout

\begin_layout Plain Layout

      Uniform4fv = glUniform4fvARB;
\end_layout

\begin_layout Plain Layout

      UniformMatrix4fv = glUniformMatrix4fvARB;
\end_layout

\begin_layout Plain Layout

      GetActiveAttrib = glGetActiveAttribARB;
\end_layout

\begin_layout Plain Layout

      GetAttribLocation = glGetAttribLocationARB;
\end_layout

\begin_layout Plain Layout

      return GL_TRUE;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   fprintf(stderr, "Sorry, GLSL not supported with this OpenGL.
\backslash
n");
\end_layout

\begin_layout Plain Layout

   return GL_FALSE;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

GLuint
\end_layout

\begin_layout Plain Layout

CompileShaderText(GLenum shaderType, const char *text)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLuint shader;
\end_layout

\begin_layout Plain Layout

   GLint stat;
\end_layout

\begin_layout Plain Layout

   GLdouble t0, t1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   shader = CreateShader(shaderType);
\end_layout

\begin_layout Plain Layout

   ShaderSource(shader, 1, (const GLchar **) &text, NULL);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   t0 = glutGet(GLUT_ELAPSED_TIME) * 0.001;
\end_layout

\begin_layout Plain Layout

   glCompileShader(shader);
\end_layout

\begin_layout Plain Layout

   t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   CompileTime = t1 - t0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   GetShaderiv(shader, GL_COMPILE_STATUS, &stat);
\end_layout

\begin_layout Plain Layout

   if (!stat) {
\end_layout

\begin_layout Plain Layout

      GLchar log[1000];
\end_layout

\begin_layout Plain Layout

      GLsizei len;
\end_layout

\begin_layout Plain Layout

      GetShaderInfoLog(shader, 1000, &len, log);
\end_layout

\begin_layout Plain Layout

      fprintf(stderr, "Error: problem compiling shader: %s
\backslash
n", log);
\end_layout

\begin_layout Plain Layout

      exit(1);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   else {
\end_layout

\begin_layout Plain Layout

      /*printf("Shader compiled OK
\backslash
n");*/
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   return shader;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Read a shader from a file.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

GLuint
\end_layout

\begin_layout Plain Layout

CompileShaderFile(GLenum shaderType, const char *filename)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   const int max = 100*1000;
\end_layout

\begin_layout Plain Layout

   int n;
\end_layout

\begin_layout Plain Layout

   char *buffer = (char*) malloc(max);
\end_layout

\begin_layout Plain Layout

   GLuint shader;
\end_layout

\begin_layout Plain Layout

   FILE *f;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   f = fopen(filename, "r");
\end_layout

\begin_layout Plain Layout

   if (!f) {
\end_layout

\begin_layout Plain Layout

      fprintf(stderr, "Unable to open shader file %s
\backslash
n", filename);
\end_layout

\begin_layout Plain Layout

      free(buffer);
\end_layout

\begin_layout Plain Layout

      return 0;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   n = fread(buffer, 1, max, f);
\end_layout

\begin_layout Plain Layout

   /*printf("read %d bytes from shader file %s
\backslash
n", n, filename);*/
\end_layout

\begin_layout Plain Layout

   if (n > 0) {
\end_layout

\begin_layout Plain Layout

      buffer[n] = 0;
\end_layout

\begin_layout Plain Layout

      shader = CompileShaderText(shaderType, buffer);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   else {
\end_layout

\begin_layout Plain Layout

      fclose(f);
\end_layout

\begin_layout Plain Layout

      free(buffer);
\end_layout

\begin_layout Plain Layout

      return 0;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   fclose(f);
\end_layout

\begin_layout Plain Layout

   free(buffer);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   return shader;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

GLuint
\end_layout

\begin_layout Plain Layout

LinkShaders(GLuint vertShader, GLuint fragShader)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   return LinkShaders3(vertShader, 0, fragShader);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

GLuint
\end_layout

\begin_layout Plain Layout

LinkShaders3(GLuint vertShader, GLuint geomShader, GLuint fragShader)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLuint program = CreateProgram();
\end_layout

\begin_layout Plain Layout

   GLdouble t0, t1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   assert(vertShader || fragShader);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   if (vertShader)
\end_layout

\begin_layout Plain Layout

      AttachShader(program, vertShader);
\end_layout

\begin_layout Plain Layout

   if (geomShader)
\end_layout

\begin_layout Plain Layout

      AttachShader(program, geomShader);
\end_layout

\begin_layout Plain Layout

   if (fragShader)
\end_layout

\begin_layout Plain Layout

      AttachShader(program, fragShader);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   t0 = glutGet(GLUT_ELAPSED_TIME) * 0.001;
\end_layout

\begin_layout Plain Layout

   LinkProgram(program);
\end_layout

\begin_layout Plain Layout

   t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   LinkTime = t1 - t0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   /* check link */
\end_layout

\begin_layout Plain Layout

   {
\end_layout

\begin_layout Plain Layout

      GLint stat;
\end_layout

\begin_layout Plain Layout

      GetProgramiv(program, GL_LINK_STATUS, &stat);
\end_layout

\begin_layout Plain Layout

      if (!stat) {
\end_layout

\begin_layout Plain Layout

         GLchar log[1000];
\end_layout

\begin_layout Plain Layout

         GLsizei len;
\end_layout

\begin_layout Plain Layout

         GetProgramInfoLog(program, 1000, &len, log);
\end_layout

\begin_layout Plain Layout

         fprintf(stderr, "Shader link error:
\backslash
n%s
\backslash
n", log);
\end_layout

\begin_layout Plain Layout

         return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   return program;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

GLuint
\end_layout

\begin_layout Plain Layout

LinkShaders3WithGeometryInfo(GLuint vertShader, GLuint geomShader, GLuint
 fragShader,
\end_layout

\begin_layout Plain Layout

                             GLint verticesOut, GLenum inputType, GLenum
 outputType)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  GLuint program = CreateProgram();
\end_layout

\begin_layout Plain Layout

  GLdouble t0, t1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  assert(vertShader || fragShader);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if (vertShader)
\end_layout

\begin_layout Plain Layout

    AttachShader(program, vertShader);
\end_layout

\begin_layout Plain Layout

  if (geomShader) {
\end_layout

\begin_layout Plain Layout

    AttachShader(program, geomShader);
\end_layout

\begin_layout Plain Layout

    glProgramParameteriARB(program, GL_GEOMETRY_VERTICES_OUT_ARB, verticesOut);
\end_layout

\begin_layout Plain Layout

    glProgramParameteriARB(program, GL_GEOMETRY_INPUT_TYPE_ARB, inputType);
\end_layout

\begin_layout Plain Layout

    glProgramParameteriARB(program, GL_GEOMETRY_OUTPUT_TYPE_ARB, outputType);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (fragShader)
\end_layout

\begin_layout Plain Layout

    AttachShader(program, fragShader);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  t0 = glutGet(GLUT_ELAPSED_TIME) * 0.001;
\end_layout

\begin_layout Plain Layout

  LinkProgram(program);
\end_layout

\begin_layout Plain Layout

  t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  LinkTime = t1 - t0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* check link */
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    GLint stat;
\end_layout

\begin_layout Plain Layout

    GetProgramiv(program, GL_LINK_STATUS, &stat);
\end_layout

\begin_layout Plain Layout

    if (!stat) {
\end_layout

\begin_layout Plain Layout

      GLchar log[1000];
\end_layout

\begin_layout Plain Layout

      GLsizei len;
\end_layout

\begin_layout Plain Layout

      GetProgramInfoLog(program, 1000, &len, log);
\end_layout

\begin_layout Plain Layout

      fprintf(stderr, "Shader link error:
\backslash
n%s
\backslash
n", log);
\end_layout

\begin_layout Plain Layout

      return 0;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return program;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

GLboolean
\end_layout

\begin_layout Plain Layout

ValidateShaderProgram(GLuint program)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLint stat;
\end_layout

\begin_layout Plain Layout

   ValidateProgramARB(program);
\end_layout

\begin_layout Plain Layout

   GetProgramiv(program, GL_VALIDATE_STATUS, &stat);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   if (!stat) {
\end_layout

\begin_layout Plain Layout

      GLchar log[1000];
\end_layout

\begin_layout Plain Layout

      GLsizei len;
\end_layout

\begin_layout Plain Layout

      GetProgramInfoLog(program, 1000, &len, log);
\end_layout

\begin_layout Plain Layout

      fprintf(stderr, "Program validation error:
\backslash
n%s
\backslash
n", log);
\end_layout

\begin_layout Plain Layout

      return 0;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   return (GLboolean) stat;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

GLdouble
\end_layout

\begin_layout Plain Layout

GetShaderCompileTime(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   return CompileTime;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

GLdouble
\end_layout

\begin_layout Plain Layout

GetShaderLinkTime(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   return LinkTime;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void
\end_layout

\begin_layout Plain Layout

SetUniformValues(GLuint program, struct uniform_info uniforms[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLuint i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   for (i = 0; uniforms[i].name; i++) {
\end_layout

\begin_layout Plain Layout

      uniforms[i].location
\end_layout

\begin_layout Plain Layout

         = glGetUniformLocation(program, uniforms[i].name);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      switch (uniforms[i].type) {
\end_layout

\begin_layout Plain Layout

      case GL_INT:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_1D:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_2D:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_3D:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_CUBE:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_2D_RECT_ARB:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_1D_SHADOW:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_2D_SHADOW:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_1D_ARRAY:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_2D_ARRAY:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_1D_ARRAY_SHADOW:
\end_layout

\begin_layout Plain Layout

      case GL_SAMPLER_2D_ARRAY_SHADOW:
\end_layout

\begin_layout Plain Layout

         assert(uniforms[i].value[0] >= 0.0F);
\end_layout

\begin_layout Plain Layout

         Uniform1i(uniforms[i].location,
\end_layout

\begin_layout Plain Layout

                     (GLint) uniforms[i].value[0]);
\end_layout

\begin_layout Plain Layout

         break;
\end_layout

\begin_layout Plain Layout

      case GL_FLOAT:
\end_layout

\begin_layout Plain Layout

         Uniform1fv(uniforms[i].location, 1, uniforms[i].value);
\end_layout

\begin_layout Plain Layout

         break;
\end_layout

\begin_layout Plain Layout

      case GL_FLOAT_VEC2:
\end_layout

\begin_layout Plain Layout

         Uniform2fv(uniforms[i].location, 1, uniforms[i].value);
\end_layout

\begin_layout Plain Layout

         break;
\end_layout

\begin_layout Plain Layout

      case GL_FLOAT_VEC3:
\end_layout

\begin_layout Plain Layout

         Uniform3fv(uniforms[i].location, 1, uniforms[i].value);
\end_layout

\begin_layout Plain Layout

         break;
\end_layout

\begin_layout Plain Layout

      case GL_FLOAT_VEC4:
\end_layout

\begin_layout Plain Layout

         Uniform4fv(uniforms[i].location, 1, uniforms[i].value);
\end_layout

\begin_layout Plain Layout

         break;
\end_layout

\begin_layout Plain Layout

      case GL_FLOAT_MAT4:
\end_layout

\begin_layout Plain Layout

         UniformMatrix4fv(uniforms[i].location, 1, GL_FALSE,
\end_layout

\begin_layout Plain Layout

                          uniforms[i].value);
\end_layout

\begin_layout Plain Layout

         break;
\end_layout

\begin_layout Plain Layout

      default:
\end_layout

\begin_layout Plain Layout

         if (strncmp(uniforms[i].name, "gl_", 3) == 0) {
\end_layout

\begin_layout Plain Layout

            /* built-in uniform: ignore */
\end_layout

\begin_layout Plain Layout

         }
\end_layout

\begin_layout Plain Layout

         else {
\end_layout

\begin_layout Plain Layout

            fprintf(stderr,
\end_layout

\begin_layout Plain Layout

                    "Unexpected uniform data type in SetUniformValues
\backslash
n");
\end_layout

\begin_layout Plain Layout

            abort();
\end_layout

\begin_layout Plain Layout

         }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/** Get list of uniforms used in the program */
\end_layout

\begin_layout Plain Layout

GLuint
\end_layout

\begin_layout Plain Layout

GetUniforms(GLuint program, struct uniform_info uniforms[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLint n, max, i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   GetProgramiv(program, GL_ACTIVE_UNIFORMS, &n);
\end_layout

\begin_layout Plain Layout

   GetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &max);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   for (i = 0; i < n; i++) {
\end_layout

\begin_layout Plain Layout

      GLint size, len;
\end_layout

\begin_layout Plain Layout

      GLenum type;
\end_layout

\begin_layout Plain Layout

      char name[100];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      glGetActiveUniform(program, i, 100, &len, &size, &type, name);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      uniforms[i].name = strdup(name);
\end_layout

\begin_layout Plain Layout

      uniforms[i].size = size;
\end_layout

\begin_layout Plain Layout

      uniforms[i].type = type;
\end_layout

\begin_layout Plain Layout

      uniforms[i].location = glGetUniformLocation(program, name);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   uniforms[i].name = NULL; /* end of list */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   return n;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void
\end_layout

\begin_layout Plain Layout

PrintUniforms(const struct uniform_info uniforms[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLint i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   printf("Uniforms:
\backslash
n");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   for (i = 0; uniforms[i].name; i++) {
\end_layout

\begin_layout Plain Layout

      printf("  %d: %s size=%d type=0x%x loc=%d value=%g, %g, %g, %g
\backslash
n",
\end_layout

\begin_layout Plain Layout

             i,
\end_layout

\begin_layout Plain Layout

             uniforms[i].name,
\end_layout

\begin_layout Plain Layout

             uniforms[i].size,
\end_layout

\begin_layout Plain Layout

             uniforms[i].type,
\end_layout

\begin_layout Plain Layout

             uniforms[i].location,
\end_layout

\begin_layout Plain Layout

             uniforms[i].value[0],
\end_layout

\begin_layout Plain Layout

             uniforms[i].value[1],
\end_layout

\begin_layout Plain Layout

             uniforms[i].value[2],
\end_layout

\begin_layout Plain Layout

             uniforms[i].value[3]);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/** Get list of attribs used in the program */
\end_layout

\begin_layout Plain Layout

GLuint
\end_layout

\begin_layout Plain Layout

GetAttribs(GLuint program, struct attrib_info attribs[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLint n, max, i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   GetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &n);
\end_layout

\begin_layout Plain Layout

   GetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &max);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   for (i = 0; i < n; i++) {
\end_layout

\begin_layout Plain Layout

      GLint size, len;
\end_layout

\begin_layout Plain Layout

      GLenum type;
\end_layout

\begin_layout Plain Layout

      char name[100];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      GetActiveAttrib(program, i, 100, &len, &size, &type, name);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      attribs[i].name = strdup(name);
\end_layout

\begin_layout Plain Layout

      attribs[i].size = size;
\end_layout

\begin_layout Plain Layout

      attribs[i].type = type;
\end_layout

\begin_layout Plain Layout

      attribs[i].location = GetAttribLocation(program, name);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   attribs[i].name = NULL; /* end of list */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   return n;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void
\end_layout

\begin_layout Plain Layout

PrintAttribs(const struct attrib_info attribs[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   GLint i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   printf("Attribs:
\backslash
n");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   for (i = 0; attribs[i].name; i++) {
\end_layout

\begin_layout Plain Layout

      printf("  %d: %s size=%d type=0x%x loc=%d
\backslash
n",
\end_layout

\begin_layout Plain Layout

             i,
\end_layout

\begin_layout Plain Layout

             attribs[i].name,
\end_layout

\begin_layout Plain Layout

             attribs[i].size,
\end_layout

\begin_layout Plain Layout

             attribs[i].type,
\end_layout

\begin_layout Plain Layout

             attribs[i].location);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Display support(shaderutil.h)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#ifndef SHADER_UTIL_H
\end_layout

\begin_layout Plain Layout

#define SHADER_UTIL_H
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#ifdef __cplusplus
\end_layout

\begin_layout Plain Layout

extern "C" {
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct uniform_info
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   const char *name;
\end_layout

\begin_layout Plain Layout

   GLuint size;  /**< number of value[] elements: 1, 2, 3 or 4 */
\end_layout

\begin_layout Plain Layout

   GLenum type;  /**< GL_FLOAT, GL_FLOAT_VEC4, GL_INT, GL_FLOAT_MAT4, etc
 */
\end_layout

\begin_layout Plain Layout

   GLfloat value[16];
\end_layout

\begin_layout Plain Layout

   GLint location;  /**< filled in by InitUniforms() */
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define END_OF_UNIFORMS   { NULL, 0, GL_NONE, { 0, 0, 0, 0 }, -1 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct attrib_info
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   const char *name;
\end_layout

\begin_layout Plain Layout

   GLuint size;  /**< number of value[] elements: 1, 2, 3 or 4 */
\end_layout

\begin_layout Plain Layout

   GLenum type;  /**< GL_FLOAT, GL_FLOAT_VEC4, GL_INT, etc */
\end_layout

\begin_layout Plain Layout

   GLint location;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLboolean
\end_layout

\begin_layout Plain Layout

ShadersSupported(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLuint
\end_layout

\begin_layout Plain Layout

CompileShaderText(GLenum shaderType, const char *text);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLuint
\end_layout

\begin_layout Plain Layout

CompileShaderFile(GLenum shaderType, const char *filename);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLuint
\end_layout

\begin_layout Plain Layout

LinkShaders(GLuint vertShader, GLuint fragShader);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLuint
\end_layout

\begin_layout Plain Layout

LinkShaders3(GLuint vertShader, GLuint geomShader, GLuint fragShader);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLuint
\end_layout

\begin_layout Plain Layout

LinkShaders3WithGeometryInfo(GLuint vertShader, GLuint geomShader, GLuint
 fragShader,
\end_layout

\begin_layout Plain Layout

                             GLint verticesOut, GLenum inputType, GLenum
 outputType);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLboolean
\end_layout

\begin_layout Plain Layout

ValidateShaderProgram(GLuint program);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLdouble
\end_layout

\begin_layout Plain Layout

GetShaderCompileTime(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLdouble
\end_layout

\begin_layout Plain Layout

GetShaderLinkTime(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern void
\end_layout

\begin_layout Plain Layout

SetUniformValues(GLuint program, struct uniform_info uniforms[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLuint
\end_layout

\begin_layout Plain Layout

GetUniforms(GLuint program, struct uniform_info uniforms[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern void
\end_layout

\begin_layout Plain Layout

PrintUniforms(const struct uniform_info uniforms[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern GLuint
\end_layout

\begin_layout Plain Layout

GetAttribs(GLuint program, struct attrib_info attribs[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern void
\end_layout

\begin_layout Plain Layout

PrintAttribs(const struct attrib_info attribs[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* These pointers are only valid after calling ShadersSupported.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

extern PFNGLCREATESHADERPROC CreateShader;
\end_layout

\begin_layout Plain Layout

extern PFNGLDELETESHADERPROC DeleteShader;
\end_layout

\begin_layout Plain Layout

extern PFNGLSHADERSOURCEPROC ShaderSource;
\end_layout

\begin_layout Plain Layout

extern PFNGLGETSHADERIVPROC GetShaderiv;
\end_layout

\begin_layout Plain Layout

extern PFNGLGETSHADERINFOLOGPROC GetShaderInfoLog;
\end_layout

\begin_layout Plain Layout

extern PFNGLCREATEPROGRAMPROC CreateProgram;
\end_layout

\begin_layout Plain Layout

extern PFNGLDELETEPROGRAMPROC DeleteProgram;
\end_layout

\begin_layout Plain Layout

extern PFNGLATTACHSHADERPROC AttachShader;
\end_layout

\begin_layout Plain Layout

extern PFNGLLINKPROGRAMPROC LinkProgram;
\end_layout

\begin_layout Plain Layout

extern PFNGLUSEPROGRAMPROC UseProgram;
\end_layout

\begin_layout Plain Layout

extern PFNGLGETPROGRAMIVPROC GetProgramiv;
\end_layout

\begin_layout Plain Layout

extern PFNGLGETPROGRAMINFOLOGPROC GetProgramInfoLog;
\end_layout

\begin_layout Plain Layout

extern PFNGLVALIDATEPROGRAMARBPROC ValidateProgramARB;
\end_layout

\begin_layout Plain Layout

extern PFNGLUNIFORM1IPROC Uniform1i;
\end_layout

\begin_layout Plain Layout

extern PFNGLUNIFORM1FVPROC Uniform1fv;
\end_layout

\begin_layout Plain Layout

extern PFNGLUNIFORM2FVPROC Uniform2fv;
\end_layout

\begin_layout Plain Layout

extern PFNGLUNIFORM3FVPROC Uniform3fv;
\end_layout

\begin_layout Plain Layout

extern PFNGLUNIFORM4FVPROC Uniform4fv;
\end_layout

\begin_layout Plain Layout

extern PFNGLGETACTIVEATTRIBPROC GetActiveAttrib;
\end_layout

\begin_layout Plain Layout

extern PFNGLGETATTRIBLOCATIONPROC GetAttribLocation;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#ifdef __cplusplus
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif /* SHADER_UTIL_H */
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
